\documentclass[a4wide, 11pt]{article}
\usepackage{a4, fullpage}
\setlength{\parskip}{0.3cm}
\setlength{\parindent}{0cm}

% This is the preamble section where you can include extra packages etc.

\begin{document}

\title{MAlice Language Specification}

\author{Alex Rozanski and Thomas Rooney}

\date{Last Updated: \today}         % inserts today's date

\maketitle            % generates the title from the data above

\section{Introduction}

This is our language specification for the MAlice programming language, which encapsulates our understanding and interpretation of the syntax and semantics of the language. This specification will form the basis for our compiler for MAlice programs.

Our definitions of syntax are provided in a semi-formal way: we are using a combination of Extended Backus-Naur Form (EBNF) and Augmented Backus-Naur form (ABNF). We are using the repetition syntax from EBNF, such as expressions surrounded by left and right braces (`{' and `}') which denotes zero or more occurrences of the expression, and left and right square brackets (`[' and `]') which denote optional expressions.

We are also using \texttt{ALPHA} and \texttt{DIGIT} from ABNF. \texttt{ALPHA} represents the letters A--Z and a--z and \texttt{DIGIT} represents the digits 0--9. This allows our specification to be more succinct and easier to read.

\section{Types}

\begin{verbatim}
Type -> "number" | "letter"
FunctionType -> Type | "looking-glass"
\end{verbatim}

MAlice is a strongly typed language. Its primitive types are \texttt{number} and \texttt{letter}, as well as the special \texttt{looking-glass} type which is analogous to a \texttt{void} type as in C-style languages. \texttt{looking-glass} can only be used in function declarations to denote that a function does not return a value.

The \texttt{number} type is used to represent signed integers, and its size is implementation-defined. The \texttt{letter} type is used to represent the letters A-Z and a-z, where letters are encoded upwards from `A' as 0 to `Z' (25), then `a' as 26 to `z' (51). \texttt{letter} variables are stored in a single byte.

\section{Functions and Programs}

\begin{verbatim}
Program      -> Function+
Function     -> "The" FunctionType Identifier ArgumentList BlockUnit

FunctionType -> Type | "looking-glass"
ArgumentList -> "(" [DeclarationList] ")"
BlockUnit    -> "opened" StatementList "closed"}
\end{verbatim}

MAlice programs can implement multiple functions. Functions begin with `The' followed by the return type, a name and a list of zero or more parameters. This is then followed by `opened', a list of statements which constitute the body, and the closing `closed' keyword. Functions are declared in the global scope and cannot be nested. The scope in which variables are declared in, is defined by the function whose \texttt{BlockUnit} they occur in. They cannot be used outside of this scope.

A MAlice program is comprised of one or more function declarations. The special function \texttt{hatta} is the entry point for MAlice programs (similar to \texttt{main} in C programs) and it is a semantic error to have this function declaration omitted.

\section{Statements}

\begin{verbatim}
StatementList -> "" | Statement "." | Statement Split StatementList
Split         -> "." | "," | "then" | "and"
               
Statement     -> DeclarationList | AssignmentList
               | Expression "said Alice"
               | Identifier "ate" | Identifier "drank"
\end{verbatim}

Function bodies in MAlice are comprised of zero or more statements. Statements are separated by either a full-stop, comma, `then' or `and'. However, the last statement in a list of one or more statements must be followed by a full stop. A single full stop is an invalid statement list.

Valid statements are:
\begin{itemize}

\item A list of one or more variable declarations (explained in the `Declarations' section).
\item A list of one or more assignment statements (explained in the `Variable Assignment' section).
\item The `said Alice' statement, which takes an expression.
\item the `drank' statement; this follows a variable identifier and decrements the variable.
\item the `drank' statement; this follows a variable identifier and increments the variable.

\end{itemize}
  
\section{Expressions}

\begin{verbatim}
Expression      -> Expression + Term | Expression - Term | Term ^ Expression | Term
Term            -> Term * Factor | Term / Factor | Factor
Factor          -> Identifier | Number | "~" (Term | Expression)

\end{verbatim}

Expressions in MAlice are only well-defined over numerical values and are constructed from terms and binary and unary operators.

\section{Operators}

There are two types of operators that Malice allows. These are the Unary Operators, and Binary Operators, named due to their acting respective on one (as a prefix) or two (in the middle) expression.

These Operators, and definitions are:

\begin{itemize}

\item
Unary Operator: `$\sim$' - This essentially means Bitwise NOT, up to the largest BIT + 1. i.e. 

\vspace{0.75mm} \hspace{25mm} \hspace{12mm} if Expr is equal to 7 == (+)0111, $\sim$Expr is equal to -8 == (-)1000

\vspace{0.75mm} \hspace{25mm} \hspace{12mm} or if Expr is equal to  0 == (+)0, $\sim$Expr is equal to -1 == (-)1
\item
Binary Operator `/' \hspace{2mm}- This is the Mathematical Division Operator. I.e. 8 / 2 = 4. In cases 

\vspace{0.75mm} \hspace{25mm} \hspace{12mm} where the result is not an integer, the Floor function can be assumed

\vspace{0.75mm} \hspace{25mm} \hspace{12mm} to operate. I.e. 5/2 = 2.
\item
Binary Operator `+' \hspace{1mm}- The Mathematical Plus Operator. i.e. 2 + 3 = 5
\item 
Binary Operator `-'\hspace{3mm} - The Mathematical Minus Operator. i.e. 4 - 2 = 2
\item
Binary Operator `*'\hspace{2.5mm} - The Mathematical Multiplication Operator. i.e. 2 * 4 = 8
\item
Binary Operator `\char`\%'\hspace{1mm} - The Mathmatical Modulus Operator. i.e.  17 \char`\%\hspace{0.57mm} 3 = 2

\end{itemize}


\section{Variable Assignment}

Variable assignment is designed to closely mirror the grammatical structure of the English language.

It is defined by the BNF Expression:

\begin{verbatim}
Assignment -> Identifier "became" Expression
\end{verbatim}

This equates to the assignment of the value returned by the evaluation of Expression into the location denoted by Identifier.

Assignments can also be done in a list, alike the BNF:
\begin{verbatim}
AssignmentList  -> Assignment [{"and" Assignment} "but" Assignment]
\end{verbatim}

\section {Returning}

The Syntax for returning is done with the `said' keyword. This is used in the form
\begin{verbatim}
ReturnExpr -> Expression "said" (Identifier|"Alice")
\end{verbatim}
In the Identifier Case, the Identifier must be equal to the function name. The Expression must also have type equivilent to the return type of the function, and fails with an error should the function be a "looking-glass" (aka Void) type.

In the "Alice" case, the Expression is evaluated and sent to stdout.

\section{Declarations}

\begin{verbatim}
  Declaration     -> Identifier "was a" Type
  DeclarationList -> Declaration [{"," Declaration ["too"]} "and" Declaration ["too"]]
\end{verbatim}

Lists of variable declarations consist of single variable declarations separated by a comma. The only exception to this is the last variable declaration, which is preceded by an `and' and no comma. For example, this is a valid variable declaration list:

\begin{verbatim}
x was a number, y was a letter and z was a number
\end{verbatim}

whilst this:

\begin{verbatim}
x was a number, y was a letter, z was a number
\end{verbatim}

is not.

Where there are one or more consecutive declarations of variables which share the same type, the second and later declarations can be optionally postfixed with `too', as in:

\begin{verbatim}
p was a letter, q was a number and r was a number too
\end{verbatim}

It is a semantic error to append `too' to a declaration for a variable whose type is different to that of the previous variable declaration's type, as in:

\begin{verbatim}
p was a letter, q was a number too and r was a number
\end{verbatim}

Variable Definitions are defined in the scope of the function that they are declared in. They cannot share the same name in one scope.

\section{BNF Grammar} 

Beginning here, we look at the formalised BNF Grammar. This utilises constructs from EBNF and ABNF as explained in the introduction to this specification.

\begin{verbatim}

Declaration     -> Identifier "was a" Type
DeclarationList -> Declaration [{"," Declaration ["too"]} "and" Declaration ["too"]]

Assignment      -> Identifier "became" Expression
AssignmentList  -> Assignment [{"and" Assignment} "but" Assignment]

BlockUnit       -> "opened" StatementList "closed"

StatementList   -> ""
                 | Statement "."
                 | Statement Split StatementList
               
Statement       -> DeclarationList
                 | AssignmentList
                 | Expression "said Alice"
                 | Identifier "ate"
                 | Identifier "drank"

Split           -> "."
                 | ","
                 | "then"

Expression      -> Expression + Term
                 | Expression - Term
                 | Term ^ Expression
                 | Term
Term            -> Term * Factor
                 | Term / Factor
                 | Factor
Factor          -> Identifier
                 | Number
                 | "~" (Term | Expression)

Program         -> Function+
Function        -> "The" FunctionType Identifier ArgumentList BlockUnit

FunctionType    -> Type
                 | "looking-glass"
ArgumentList    -> "(" [DeclarationList] ")"

Value           -> Number | Letter

Letter          -> ALPHA

Number          -> ["-"] DIGIT+

Type            -> "number"
                 | "letter"

\end{verbatim}



\end{document}
