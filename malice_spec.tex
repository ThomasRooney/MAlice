\documentclass[a4wide, 11pt]{article}
\usepackage{a4, fullpage}
\setlength{\parskip}{0.3cm}
\setlength{\parindent}{0cm}
\usepackage[hmargin=2.5cm,vmargin=2.5cm]{geometry}

% This is the preamble section where you can include extra packages etc.


\begin{document}

\title{MAlice Language Specification}

\author{Alex Rozanski and Thomas Rooney}

\date{Last Updated: \today}         % inserts today's date

\maketitle            % generates the title from the data above

\section{Introduction}

This is our language specification for the MAlice programming language, which encapsulates our understanding and interpretation of the syntax and semantics of the language. This specification will form the basis for our compiler for MAlice programs.

Our definitions of syntax are provided in a semi-formal way: we are using a combination of Extended Backus-Naur Form (EBNF) and Augmented Backus-Naur form (ABNF). We are using the repetition syntax from EBNF, such as expressions surrounded by left and right braces (`\{' and `\}') which denotes zero or more occurrences of the expression, and left and right square brackets (`[' and `]') which denote optional expressions.

We are also using \texttt{ALPHA} and \texttt{DIGIT} from ABNF. \texttt{ALPHA} represents the letters \texttt{A-Z} and \texttt{a-z} and \texttt{DIGIT} represents the digits \texttt{0-9}. This allows our specification to be more succinct and easier to read.

\section{Types}

\begin{verbatim}
Type         -> "number" | "letter"
FunctionType -> Type | "looking-glass"
\end{verbatim}

MAlice is a strongly typed language. Its primitive types are \texttt{number} and \texttt{letter}, as well as the special \texttt{looking-glass} type which is analogous to a \texttt{void} type as in C-style languages. \texttt{looking-glass} can only be used in function declarations to denote that a function does not return a value.

The \texttt{number} type is used to represent signed integers. It is represented internally using Two's Complement format, but its size is implementation-defined. The \texttt{letter} type is used to represent the letters \texttt{A-Z} and \texttt{a-z}, where letters are encoded upwards from `A' (stored as 0) to `Z' (25), then `a' (26) to `z' (51). As such we store \texttt{letter} variables in a single byte.

\section{Functions and Programs}

\begin{verbatim}
Program      -> Function+
Function     -> "The" FunctionType Identifier ArgumentList BlockUnit

FunctionType -> Type | "looking-glass"
ArgumentList -> "(" [DeclarationList] ")"
BlockUnit    -> "opened" StatementList "closed"
\end{verbatim}

MAlice programs can implement multiple functions. Functions begin with `The' followed by the return type, a name and a list of zero or more parameters, which are enclosed in brackets. The method body is then enclosed by the \texttt{opened} and \texttt{closed} keywords. The scope in which variables are declared in is defined by the function whose \texttt{BlockUnit} they occur in. They cannot be used outside of this scope. Functions are declared in the global scope and cannot be nested. 

For example:

\begin{verbatim}
The looking-glass myFunction ()
opened
     ...
closed
\end{verbatim}

This declares the function \texttt{myFunction} which has no return type.


A MAlice program is comprised of one or more function declarations. The special function \texttt{hatta} is the entry point for MAlice programs (similar to \texttt{main} in C programs) and it is a semantic error to have this function declaration omitted.

\section{Statements}

\begin{verbatim}
StatementList -> "" | Statement "." | Statement Split StatementList
Split         -> "." | "," | "then" | "and"
               
Statement     -> DeclarationList | AssignmentList
               | Expression "said Alice"
               | Identifier "ate" | Identifier "drank"
\end{verbatim}

Function bodies in MAlice are comprised of zero or more statements. Statements are separated by either a full-stop, comma, `then' or `and'. However, the last statement in a list of one or more statements must be followed by a full stop. A single full stop is an invalid statement list.

Valid statements are:
\begin{itemize}

\item A list of one or more variable declarations (explained in the `Variable Declarations' section).
\item A list of one or more assignment statements (explained in the `Variable Assignment' section).
\item The `said Alice' statement, which takes an expression and prints its value to the console.
\item the `drank' statement; this follows a variable identifier and decrements the variable.
\item the `ate' statement; this follows a variable identifier and increments the variable.

\end{itemize}
  
\section{Expressions}

\begin{verbatim}
Expression -> Expression + Term | Expression - Term | Term ^ Expression | Term
Term       -> Term * Factor | Term / Factor | Factor
Factor     -> Identifier | Number | "~" (Term | Expression)

\end{verbatim}

Expressions in MAlice are only well-defined over numerical values and are constructed from terms and binary and unary operators.

\section{Operators}

MAlice supports commonly used unary and binary mathematical operators which we define to act on expressions.

It supports the bitwise NOT unary operator, which is denoted by the tilde symbol. This performs a bitwise NOT on the evaluated number it is applied to (remembering that the \texttt{number} type in MAlice has a Two's Complement binary representation.)

MAlice also supports the following binary operators:

\begin{list}{} {
\setlength{\labelsep}{0.75cm}
\setlength{\leftmargin}{2cm}
}

\item[\texttt{+}] the mathematical plus operator.
\item[\texttt{-}] the mathematical minus operator.
\item[\texttt{*}] the mathematical multiplication operator.
\item[\texttt{/}] the mathematical division operator. This will throw a runtime error should the right hand operator be equal to zero.
\item[\texttt{\%}] the mathematical modulo operator.
\item[\texttt{\^}] the mathematical exponent operator.

\end{list}

All of the operators are left-associative, except for the exponent operator which is right-associative. These associativities can be seen in the BNF for \texttt{Expression} and \texttt{Term} productions in the `Expressions' section above.

\section{Variable Declarations}

\begin{verbatim}
  Declaration     -> Identifier "was a" Type
  DeclarationList -> Declaration [{"," Declaration ["too"]} "and" Declaration ["too"]]
\end{verbatim}

Lists of variable declarations consist of single variable declarations separated by a comma. The only exception to this is the last variable declaration, which is preceded by an `and' and no comma. For example, this is a valid variable declaration list:

\begin{verbatim}
x was a number, y was a letter and z was a number
\end{verbatim}

whilst this:

\begin{verbatim}
x was a number, y was a letter, z was a number
\end{verbatim}

is not.

Where there are one or more consecutive declarations of variables which share the same type, the second and later declarations can be optionally postfixed with `too', as in:

\begin{verbatim}
p was a letter, q was a number and r was a number too
\end{verbatim}

It is a semantic error to append `too' to a declaration for a variable whose type is different to that of the previous variable declaration's type, as in:

\begin{verbatim}
p was a letter, q was a number too and r was a number
\end{verbatim}

Variable Definitions are defined in the scope of the function that they are declared in. They cannot share the same name in one scope.

\section{Variable Assignment}

Variable assignment is designed to closely mirror the grammatical structure of the English language.

It is defined by the BNF Expression:

\begin{verbatim}
Assignment -> Identifier "became" Expression
AssignmentList -> Assignment [{"and" Assignment} "but" Assignment]
\end{verbatim}

This equates to the assignment of the value returned by the evaluation of Expression into the location denoted by Identifier.

Assignments can also be done in a list, with `and' between two assignments but the final two, where `but' is used

\section {Returning}

The Syntax for returning is done with the `said' keyword. This is used in the form
\begin{verbatim}
ReturnExpr -> Expression "said" (Identifier|"Alice")
\end{verbatim}
In the Identifier Case, the Identifier must be equal to the function name. The Expression must also have type equivilent to the return type of the function, and fails with an error should the function be a \texttt{looking-glass} (aka Void) type.

In the \texttt{Alice} case, the Expression is evaluated and sent to \texttt{stdout}.


\end{document}
