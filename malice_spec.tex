\documentclass[a4wide, 11pt]{article}
\usepackage{a4, fullpage}
\setlength{\parskip}{0.3cm}
\setlength{\parindent}{0cm}
% \usepackage[hmargin=2.5cm,vmargin=2.5cm]{geometry}

% This is the preamble section where you can include extra packages etc.


\begin{document}

\title{MAlice Language Specification}

\author{Alex Rozanski and Thomas Rooney}

\date{Last Updated: \today}         % inserts today's date

\maketitle            % generates the title from the data above

\section{Introduction}

This is our language specification for the MAlice programming language, which encapsulates our understanding and interpretation of the syntax and semantics of the language. This specification will form the basis for our compiler for MAlice programs.

Our definitions of syntax are provided in a semi-formal way: we are using a combination of Extended Backus-Naur Form (EBNF) and Augmented Backus-Naur form (ABNF). We are using the repetition syntax from EBNF, such as expressions surrounded by left and right braces (`\{' and `\}') which denotes zero or more occurrences of the expression, and left and right square brackets (`[' and `]') which denote optional expressions.

We are also using \texttt{ALPHA} and \texttt{DIGIT} from ABNF. \texttt{ALPHA} represents the letters \texttt{A-Z} and \texttt{a-z} and \texttt{DIGIT} represents the digits \texttt{0-9}. We also define and use \texttt{LOWERALPHA} to denote the lowercase alphabetic characters. Using these allows our specification to be more succinct and easier to read.

\section{Types and Identifiers}

\begin{verbatim}
Type         -> "number" | "letter"
FunctionType -> Type | "looking-glass"
Identifier   -> LOWERALPHA [{ ALPHA | "-" } ALPHA]
\end{verbatim}

MAlice is a strongly typed language. Its primitive types are \texttt{number} and \texttt{letter}, as well as the special \texttt{looking-glass} type which is analogous to a \texttt{void} type as in C-style languages. \texttt{looking-glass} can only be used in function declarations to denote that a function does not return a value.

The \texttt{number} type is used to represent signed integers. It is represented internally using Two's Complement format, but its size is implementation-defined. When \texttt{number} variables are declared they default to 0.

The \texttt{letter} type is used to represent the letters \texttt{A-Z} and \texttt{a-z}, where letters are encoded upwards from `A' (stored as 0) to `Z' (25), then `a' (26) to `z' (51). As such we store \texttt{letter} variables in a single byte. \texttt{letter} variables default to `A' when they are declared.

Identifiers are used to reference variables and function names. They consist of strings of one or more alphabetic characters and dashes, where the first character is lowercase. Identifiers cannot end with a dash.

\section{Functions and Programs}

\begin{verbatim}
Program      -> Function+
Function     -> "The" FunctionType Identifier ArgumentList BlockUnit

FunctionType ->  Type | "looking-glass"
ArgumentList -> "(" [DeclarationList] ")"
BlockUnit    -> "opened" StatementList "closed"
\end{verbatim}

MAlice programs can implement multiple functions, but must have the entry point, \texttt{hatta}. Functions begin with `The' followed by the return type, a name and a list of zero or more parameters, which are enclosed in brackets. The method body is then enclosed by the \texttt{opened} and \texttt{closed} keywords. The scope in which variables are declared in is defined by the function whose \texttt{BlockUnit} they occur in. They cannot be used outside of this scope. Functions are declared in the global scope and cannot be nested. 

% For example:

% \begin{verbatim}
% The looking-glass myFunction ()
% opened
%      ...
% closed
% \end{verbatim}

% This declares the function \texttt{myFunction} which has no return type.

A MAlice program, in this limited specification, is comprised of only one function declaration. The special function \texttt{hatta}, which  is the entry point for MAlice programs (similar to \texttt{main} in C programs) and it is a compile time error to have this function declaration omitted.

The example programs provided have not specified any syntax which we could interpret to be used for calling functions. However, we assume that this could be done by adding our own syntax, specified with the following BNF productions:

\begin{verbatim}
FunctionCall         -> Identifier "(" [FunctionCallList] ")"
FunctionCallList     -> FunctionCallArgument {("," | "and") FunctionCallArgument}
FunctionCallArgument -> Expression | Character
\end{verbatim}

Returning a value from a function is done using the `said' statement, which is explained in more detail in the `Statements' section.

\section{Statements}

\begin{verbatim}
StatementList -> "" | Statement "." | Statement Split StatementList
Split         -> "." | "," | "then" | "and" | "but"

Statement     -> Declaration | Assignment
               | (Expression | Character) "said" (Alice| Identifier)
               | Identifier "ate" | Identifier "drank"
\end{verbatim}

Function bodies in MAlice are comprised of zero or more statements. Statements are separated by either a full-stop, comma, `then' or `and'. However, the last statement in a list of one or more statements must be followed by a full stop. A single full stop is an invalid statement list.

\subsection{Variable Declaration and Assignment}

\begin{verbatim}
  Declaration     -> Identifier "was a" Type ["too"]
  Assignment      -> Identifier "became" (Expression | Character)
  Character       -> "`" ALPHA "'"
\end{verbatim}

Lists of variable declarations consist of single variable declarations separated by a comma. The only exception to this is the last variable declaration, which is preceded by an `and' and no comma.

Where there are one or more consecutive declarations of variables which share the same type, the second and later declarations can be optionally postfixed with `too', as in \texttt{p was a letter, q was a number and r was a number too}. However, it is a semantic error to append `too' to a declaration for a variable whose type is different to that of the previous variable declaration's type.

Variables are defined in the scope of the function that they are declared in. It is a semantic error for a variable to be declared if a variable with that identifier has already been declared in the same scope.

Variable assignments are only semantically correct if a \texttt{number} variable is assigned an expression and a \texttt{letter} variable is assigned a character (as described in the \texttt{Character} production above).

\subsection{The `said' Statement}

The \texttt{said} statement has two uses:
\begin{itemize}
\item \textbf{Printing to the Console:} \texttt{said} can be used to print to stdout using the form: $\langle$\texttt{Expression | Character}$\rangle$ \texttt{said Alice}. Should this be an expression, this statement prints out the evaluated result. Otherwise, it prints out the raw character value, enclosed in single quotation marks. None of the included examples demonstrated this case of printing a character, but we decided to add this so as to not limit the language unnecessarily. References to identifiers (be that in an expression or on their own) print out either the numeric or character result, based on the accompanying variable's type.
\item \textbf{Returning a Value:} \texttt{said} can also be used to return a value for functions which do not have the \texttt{looking-glass} return type. This is not in any of the example programs, but given that we allow implementing functions with a return type other than \texttt{looking-glass} we need syntax and semantics for functions to return a value. The way that \texttt{said} is used to return values is with the format $\langle$\texttt{Expression | Character}$\rangle$ \texttt{said} $\langle$\texttt{Identifier}$\rangle$. This is used to return control immediately back to the calling function, passing it back the result (left hand argument). If \texttt{Identifier} is not equal to the name of the function, this results in a compile-time error. We feel that this syntax preserves the natural language feel of MAlice.
\end{itemize}

\subsection{`drank' and `ate' Statements}

The \texttt{drank} and \texttt{ate} keywords follows a variable identifier, and decrements and increments the variable respectively.
  
\section{Expressions}

\begin{verbatim}
Expression -> Expression + Term | Expression - Term | Term ^ Expression | Term
Term       -> Term * Factor | Term / Factor | Factor
Factor     -> Identifier | Number | "~" (Term | Expression)

\end{verbatim}

Expressions in MAlice are only well-defined over numerical values and are constructed from terms and binary and unary operators.

\subsection{Operators}

MAlice supports commonly used unary and binary mathematical operators which we define to act on expressions.

It supports the bitwise NOT unary operator, which is denoted by the tilde symbol. This performs a bitwise NOT on the evaluated number it is applied to (remembering that the \texttt{number} type in MAlice has a Two's Complement binary representation.)

MAlice also supports the following binary operators:

\begin{list}{} {
\setlength{\labelsep}{0.75cm}
\setlength{\leftmargin}{2cm}
}

\item[\texttt{+}] the mathematical plus operator.
\item[\texttt{-}] the mathematical minus operator.
\item[\texttt{*}] the mathematical multiplication operator.
\item[\texttt{/}] the mathematical division operator. This will throw a runtime error should the right hand operator be equal to zero.
\item[\texttt{\%}] the mathematical modulo operator.
\item[\texttt{\^}] the mathematical exponent operator.

\end{list}

All of the operators are left-associative, except for the exponent operator which is right-associative. These associativities can be seen in the BNF for \texttt{Expression} and \texttt{Term} productions in the `Expressions' section above.

\end{document}
