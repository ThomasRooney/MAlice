/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g
 *     -                            On : 2012-11-20 12:33:43
 *     -                for the parser : MAliceParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "MAliceParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pMAliceParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pMAliceParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pMAliceParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pMAliceParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   MAliceParserTokenNames[61+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ALICEFOUND",
        (pANTLR3_UINT8) "AND",
        (pANTLR3_UINT8) "BECAME",
        (pANTLR3_UINT8) "BUT",
        (pANTLR3_UINT8) "CHARACTER_LITERAL",
        (pANTLR3_UINT8) "CLOSED",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "LETTER",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "NEWLINE",
        (pANTLR3_UINT8) "NUMBER_LITERAL",
        (pANTLR3_UINT8) "OPENED",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "SPOKE",
        (pANTLR3_UINT8) "STRING_LITERAL",
        (pANTLR3_UINT8) "THELOOKINGGLASS",
        (pANTLR3_UINT8) "THEN",
        (pANTLR3_UINT8) "THEROOM",
        (pANTLR3_UINT8) "WASA",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'&&'",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "'0'",
        (pANTLR3_UINT8) "'9'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'<='",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>='",
        (pANTLR3_UINT8) "'?'",
        (pANTLR3_UINT8) "'\\'s'",
        (pANTLR3_UINT8) "'^'",
        (pANTLR3_UINT8) "'_'",
        (pANTLR3_UINT8) "'because Alice was unsure which'",
        (pANTLR3_UINT8) "'because'",
        (pANTLR3_UINT8) "'contained a'",
        (pANTLR3_UINT8) "'enough times'",
        (pANTLR3_UINT8) "'eventually'",
        (pANTLR3_UINT8) "'letter'",
        (pANTLR3_UINT8) "'maybe'",
        (pANTLR3_UINT8) "'number'",
        (pANTLR3_UINT8) "'of'",
        (pANTLR3_UINT8) "'or'",
        (pANTLR3_UINT8) "'perhaps'",
        (pANTLR3_UINT8) "'piece'",
        (pANTLR3_UINT8) "'sentence'",
        (pANTLR3_UINT8) "'so'",
        (pANTLR3_UINT8) "'too'",
        (pANTLR3_UINT8) "'what was'",
        (pANTLR3_UINT8) "'|'",
        (pANTLR3_UINT8) "'||'",
        (pANTLR3_UINT8) "'~'"
       };

const char *
ruleNames[] =
	{
		"invalidRule", "if_block", "constant", "declaration_split", "procedure", 
		"spoke_statement", "additive_expr", "return_statement", "multiplicactive_expr", 
		"proc_func_invocation", "statement_component", "lvalue", "block_unit", 
		"variable_declaration", "assignment", "declaration_argument_list", "split", 
		"function", "while_loop", "assignment_expr", "proc_func_invocation_argument_list", 
		"statement_list", "type", "boolean_expression", "bitwise_expr", "else_block", 
		"single_boolean_expression", "declaration_argument", "expression", "declaration_list", 
		"input_statement", "synpred1_MAlice", "program", "unary_expr", "identifier"
	};

 
static ANTLR3_UINT32 ruleLevel = 0;
static ANTLR3_UINT32 getRuleLevel()
{
	return ruleLevel;
}
static void incRuleLevel()
{
	ruleLevel++;
}
static void decRuleLevel()
{
	ruleLevel--;
}
static ANTLR3_BOOLEAN
evalPredicate(pMAliceParser ctx, ANTLR3_BOOLEAN result, const char * predicate)
{
    DBG->semanticPredicate(DBG, result, predicate);
    return result;
}


// Forward declare the locally static matching functions we have generated.
//
static 
 void
	type    (pMAliceParser ctx);
static 
 void
	constant    (pMAliceParser ctx);
static 
 void
	program    (pMAliceParser ctx);
static 
 void
	function    (pMAliceParser ctx);
static 
 void
	declaration_argument_list    (pMAliceParser ctx);
static 
 void
	procedure    (pMAliceParser ctx);
static 
 void
	declaration_argument    (pMAliceParser ctx);
static 
 void
	block_unit    (pMAliceParser ctx);
static 
 void
	proc_func_invocation    (pMAliceParser ctx);
static 
 void
	proc_func_invocation_argument_list    (pMAliceParser ctx);
static 
 void
	assignment    (pMAliceParser ctx);
static 
 void
	declaration_split    (pMAliceParser ctx);
static 
 void
	split    (pMAliceParser ctx);
static 
 void
	statement_component    (pMAliceParser ctx);
static 
 void
	statement_list    (pMAliceParser ctx);
static 
 void
	return_statement    (pMAliceParser ctx);
static 
 void
	while_loop    (pMAliceParser ctx);
static 
 void
	if_block    (pMAliceParser ctx);
static 
 void
	else_block    (pMAliceParser ctx);
static 
 void
	declaration_list    (pMAliceParser ctx);
static 
 void
	variable_declaration    (pMAliceParser ctx);
static 
 void
	input_statement    (pMAliceParser ctx);
static 
 void
	spoke_statement    (pMAliceParser ctx);
static 
 void
	expression    (pMAliceParser ctx);
static 
 void
	assignment_expr    (pMAliceParser ctx);
static 
 void
	lvalue    (pMAliceParser ctx);
static 
 void
	additive_expr    (pMAliceParser ctx);
static 
 void
	multiplicactive_expr    (pMAliceParser ctx);
static 
 void
	bitwise_expr    (pMAliceParser ctx);
static 
 void
	unary_expr    (pMAliceParser ctx);
static 
 void
	boolean_expression    (pMAliceParser ctx);
static 
 void
	single_boolean_expression    (pMAliceParser ctx);
static 
 void
	identifier    (pMAliceParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred1_MAlice    (pMAliceParser ctx);
static void	MAliceParserFree(pMAliceParser ctx);
static void     MAliceParserReset (pMAliceParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new MAliceParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pMAliceParser
MAliceParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return MAliceParserNewSSD(instream, NULL);
}

/** \brief Create a new MAliceParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pMAliceParser
MAliceParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pMAliceParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pMAliceParser) ANTLR3_CALLOC(1, sizeof(MAliceParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in MAliceParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our MAliceParser interface
     */
    ctx->type	= type;
    ctx->constant	= constant;
    ctx->program	= program;
    ctx->function	= function;
    ctx->declaration_argument_list	= declaration_argument_list;
    ctx->procedure	= procedure;
    ctx->declaration_argument	= declaration_argument;
    ctx->block_unit	= block_unit;
    ctx->proc_func_invocation	= proc_func_invocation;
    ctx->proc_func_invocation_argument_list	= proc_func_invocation_argument_list;
    ctx->assignment	= assignment;
    ctx->declaration_split	= declaration_split;
    ctx->split	= split;
    ctx->statement_component	= statement_component;
    ctx->statement_list	= statement_list;
    ctx->return_statement	= return_statement;
    ctx->while_loop	= while_loop;
    ctx->if_block	= if_block;
    ctx->else_block	= else_block;
    ctx->declaration_list	= declaration_list;
    ctx->variable_declaration	= variable_declaration;
    ctx->input_statement	= input_statement;
    ctx->spoke_statement	= spoke_statement;
    ctx->expression	= expression;
    ctx->assignment_expr	= assignment_expr;
    ctx->lvalue	= lvalue;
    ctx->additive_expr	= additive_expr;
    ctx->multiplicactive_expr	= multiplicactive_expr;
    ctx->bitwise_expr	= bitwise_expr;
    ctx->unary_expr	= unary_expr;
    ctx->boolean_expression	= boolean_expression;
    ctx->single_boolean_expression	= single_boolean_expression;
    ctx->identifier	= identifier;
    ctx->synpred1_MAlice	= synpred1_MAlice;
    ctx->free			= MAliceParserFree;
    ctx->reset			= MAliceParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = MAliceParserTokenNames;

    {
    	// DEBUG MODE code
    	//
    	pANTLR3_DEBUG_EVENT_LISTENER	 proxy;
    	proxy = antlr3DebugListenerNew();
    	proxy->grammarFileName = INPUT->tokenSource->strFactory->newStr8(INPUT->tokenSource->strFactory, (pANTLR3_UINT8)ctx->getGrammarFileName());

    	PARSER->setDebugListener(PARSER, proxy);

    	// Try to connect to the debugger (waits forever for a connection)
    	//
    	proxy->handshake(proxy);

    	// End DEBUG MODE code
    	//
    }


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
MAliceParserReset (pMAliceParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 MAliceParserFree(pMAliceParser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return MAliceParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_in_program92  */
static	ANTLR3_BITWORD FOLLOW_function_in_program92_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000500002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_in_program92	= { FOLLOW_function_in_program92_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedure_in_program94  */
static	ANTLR3_BITWORD FOLLOW_procedure_in_program94_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000500002) };
static  ANTLR3_BITSET_LIST FOLLOW_procedure_in_program94	= { FOLLOW_procedure_in_program94_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THEROOM_in_function103  */
static	ANTLR3_BITWORD FOLLOW_THEROOM_in_function103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_THEROOM_in_function103	= { FOLLOW_THEROOM_in_function103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_function105  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_function105_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_function105	= { FOLLOW_identifier_in_function105_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_function107  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_function107_bits[]	= { ANTLR3_UINT64_LIT(0x0428000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_function107	= { FOLLOW_LPAREN_in_function107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_argument_list_in_function109  */
static	ANTLR3_BITWORD FOLLOW_declaration_argument_list_in_function109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_argument_list_in_function109	= { FOLLOW_declaration_argument_list_in_function109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_function112  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_function112_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_function112	= { FOLLOW_RPAREN_in_function112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_function114  */
static	ANTLR3_BITWORD FOLLOW_48_in_function114_bits[]	= { ANTLR3_UINT64_LIT(0x0428000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_function114	= { FOLLOW_48_in_function114_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_function116  */
static	ANTLR3_BITWORD FOLLOW_type_in_function116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_function116	= { FOLLOW_type_in_function116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_unit_in_function118  */
static	ANTLR3_BITWORD FOLLOW_block_unit_in_function118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_unit_in_function118	= { FOLLOW_block_unit_in_function118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_argument_in_declaration_argument_list129  */
static	ANTLR3_BITWORD FOLLOW_declaration_argument_in_declaration_argument_list129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_argument_in_declaration_argument_list129	= { FOLLOW_declaration_argument_in_declaration_argument_list129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_declaration_argument_list131  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_declaration_argument_list131_bits[]	= { ANTLR3_UINT64_LIT(0x0428000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_declaration_argument_list131	= { FOLLOW_COMMA_in_declaration_argument_list131_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_argument_in_declaration_argument_list135  */
static	ANTLR3_BITWORD FOLLOW_declaration_argument_in_declaration_argument_list135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_argument_in_declaration_argument_list135	= { FOLLOW_declaration_argument_in_declaration_argument_list135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_THELOOKINGGLASS_in_procedure145  */
static	ANTLR3_BITWORD FOLLOW_THELOOKINGGLASS_in_procedure145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_THELOOKINGGLASS_in_procedure145	= { FOLLOW_THELOOKINGGLASS_in_procedure145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_procedure147  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_procedure147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_procedure147	= { FOLLOW_identifier_in_procedure147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_procedure149  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_procedure149_bits[]	= { ANTLR3_UINT64_LIT(0x0428000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_procedure149	= { FOLLOW_LPAREN_in_procedure149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_argument_list_in_procedure151  */
static	ANTLR3_BITWORD FOLLOW_declaration_argument_list_in_procedure151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_argument_list_in_procedure151	= { FOLLOW_declaration_argument_list_in_procedure151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_procedure154  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_procedure154_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_procedure154	= { FOLLOW_RPAREN_in_procedure154_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_unit_in_procedure156  */
static	ANTLR3_BITWORD FOLLOW_block_unit_in_procedure156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_unit_in_procedure156	= { FOLLOW_block_unit_in_procedure156_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_declaration_argument170  */
static	ANTLR3_BITWORD FOLLOW_type_in_declaration_argument170_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_declaration_argument170	= { FOLLOW_type_in_declaration_argument170_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_declaration_argument172  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_declaration_argument172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_declaration_argument172	= { FOLLOW_identifier_in_declaration_argument172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENED_in_block_unit196  */
static	ANTLR3_BITWORD FOLLOW_OPENED_in_block_unit196_bits[]	= { ANTLR3_UINT64_LIT(0x2104000200501010) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENED_in_block_unit196	= { FOLLOW_OPENED_in_block_unit196_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_list_in_block_unit199  */
static	ANTLR3_BITWORD FOLLOW_declaration_list_in_block_unit199_bits[]	= { ANTLR3_UINT64_LIT(0x2104000200001010) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_list_in_block_unit199	= { FOLLOW_declaration_list_in_block_unit199_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_list_in_block_unit203  */
static	ANTLR3_BITWORD FOLLOW_statement_list_in_block_unit203_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_list_in_block_unit203	= { FOLLOW_statement_list_in_block_unit203_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSED_in_block_unit205  */
static	ANTLR3_BITWORD FOLLOW_CLOSED_in_block_unit205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSED_in_block_unit205	= { FOLLOW_CLOSED_in_block_unit205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_proc_func_invocation215  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_proc_func_invocation215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_proc_func_invocation215	= { FOLLOW_identifier_in_proc_func_invocation215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_proc_func_invocation217  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_proc_func_invocation217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000028100) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_proc_func_invocation217	= { FOLLOW_LPAREN_in_proc_func_invocation217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_proc_func_invocation_argument_list_in_proc_func_invocation219  */
static	ANTLR3_BITWORD FOLLOW_proc_func_invocation_argument_list_in_proc_func_invocation219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_proc_func_invocation_argument_list_in_proc_func_invocation219	= { FOLLOW_proc_func_invocation_argument_list_in_proc_func_invocation219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_proc_func_invocation222  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_proc_func_invocation222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_proc_func_invocation222	= { FOLLOW_RPAREN_in_proc_func_invocation222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_proc_func_invocation_argument_list235  */
static	ANTLR3_BITWORD FOLLOW_constant_in_proc_func_invocation_argument_list235_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_proc_func_invocation_argument_list235	= { FOLLOW_constant_in_proc_func_invocation_argument_list235_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_proc_func_invocation_argument_list237  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_proc_func_invocation_argument_list237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008100) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_proc_func_invocation_argument_list237	= { FOLLOW_COMMA_in_proc_func_invocation_argument_list237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_proc_func_invocation_argument_list241  */
static	ANTLR3_BITWORD FOLLOW_constant_in_proc_func_invocation_argument_list241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_proc_func_invocation_argument_list241	= { FOLLOW_constant_in_proc_func_invocation_argument_list241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lvalue_in_assignment253  */
static	ANTLR3_BITWORD FOLLOW_lvalue_in_assignment253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_lvalue_in_assignment253	= { FOLLOW_lvalue_in_assignment253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BECAME_in_assignment255  */
static	ANTLR3_BITWORD FOLLOW_BECAME_in_assignment255_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_BECAME_in_assignment255	= { FOLLOW_BECAME_in_assignment255_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_assignment257  */
static	ANTLR3_BITWORD FOLLOW_expression_in_assignment257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_assignment257	= { FOLLOW_expression_in_assignment257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_split291  */
static	ANTLR3_BITWORD FOLLOW_33_in_split291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_split291	= { FOLLOW_33_in_split291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_return_statement_in_statement_component300  */
static	ANTLR3_BITWORD FOLLOW_return_statement_in_statement_component300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_return_statement_in_statement_component300	= { FOLLOW_return_statement_in_statement_component300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_while_loop_in_statement_component305  */
static	ANTLR3_BITWORD FOLLOW_while_loop_in_statement_component305_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_while_loop_in_statement_component305	= { FOLLOW_while_loop_in_statement_component305_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_if_block_in_statement_component310  */
static	ANTLR3_BITWORD FOLLOW_if_block_in_statement_component310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_if_block_in_statement_component310	= { FOLLOW_if_block_in_statement_component310_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_expr_in_statement_component316  */
static	ANTLR3_BITWORD FOLLOW_assignment_expr_in_statement_component316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_expr_in_statement_component316	= { FOLLOW_assignment_expr_in_statement_component316_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_input_statement_in_statement_component321  */
static	ANTLR3_BITWORD FOLLOW_input_statement_in_statement_component321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_input_statement_in_statement_component321	= { FOLLOW_input_statement_in_statement_component321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_statement_component326  */
static	ANTLR3_BITWORD FOLLOW_33_in_statement_component326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_statement_component326	= { FOLLOW_33_in_statement_component326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_component_in_statement_list337  */
static	ANTLR3_BITWORD FOLLOW_statement_component_in_statement_list337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_component_in_statement_list337	= { FOLLOW_statement_component_in_statement_list337_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_split_in_statement_list341  */
static	ANTLR3_BITWORD FOLLOW_split_in_statement_list341_bits[]	= { ANTLR3_UINT64_LIT(0x2104000200001010) };
static  ANTLR3_BITSET_LIST FOLLOW_split_in_statement_list341	= { FOLLOW_split_in_statement_list341_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_component_in_statement_list343  */
static	ANTLR3_BITWORD FOLLOW_statement_component_in_statement_list343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_component_in_statement_list343	= { FOLLOW_statement_component_in_statement_list343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ALICEFOUND_in_return_statement360  */
static	ANTLR3_BITWORD FOLLOW_ALICEFOUND_in_return_statement360_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008100) };
static  ANTLR3_BITSET_LIST FOLLOW_ALICEFOUND_in_return_statement360	= { FOLLOW_ALICEFOUND_in_return_statement360_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_return_statement362  */
static	ANTLR3_BITWORD FOLLOW_constant_in_return_statement362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_return_statement362	= { FOLLOW_constant_in_return_statement362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_50_in_while_loop374  */
static	ANTLR3_BITWORD FOLLOW_50_in_while_loop374_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_50_in_while_loop374	= { FOLLOW_50_in_while_loop374_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_while_loop376  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_while_loop376_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_while_loop376	= { FOLLOW_boolean_expression_in_while_loop376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_47_in_while_loop378  */
static	ANTLR3_BITWORD FOLLOW_47_in_while_loop378_bits[]	= { ANTLR3_UINT64_LIT(0x2104000200001010) };
static  ANTLR3_BITSET_LIST FOLLOW_47_in_while_loop378	= { FOLLOW_47_in_while_loop378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_list_in_while_loop380  */
static	ANTLR3_BITWORD FOLLOW_statement_list_in_while_loop380_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_list_in_while_loop380	= { FOLLOW_statement_list_in_while_loop380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_49_in_while_loop382  */
static	ANTLR3_BITWORD FOLLOW_49_in_while_loop382_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_49_in_while_loop382	= { FOLLOW_49_in_while_loop382_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_if_block394  */
static	ANTLR3_BITWORD FOLLOW_56_in_if_block394_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_56_in_if_block394	= { FOLLOW_56_in_if_block394_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_if_block396  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_if_block396_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_if_block396	= { FOLLOW_boolean_expression_in_if_block396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_59_in_if_block398  */
static	ANTLR3_BITWORD FOLLOW_59_in_if_block398_bits[]	= { ANTLR3_UINT64_LIT(0x2104000200001010) };
static  ANTLR3_BITSET_LIST FOLLOW_59_in_if_block398	= { FOLLOW_59_in_if_block398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_list_in_if_block400  */
static	ANTLR3_BITWORD FOLLOW_statement_list_in_if_block400_bits[]	= { ANTLR3_UINT64_LIT(0x0080400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_list_in_if_block400	= { FOLLOW_statement_list_in_if_block400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_else_block_in_if_block402  */
static	ANTLR3_BITWORD FOLLOW_else_block_in_if_block402_bits[]	= { ANTLR3_UINT64_LIT(0x0080400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_else_block_in_if_block402	= { FOLLOW_else_block_in_if_block402_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_if_block405  */
static	ANTLR3_BITWORD FOLLOW_46_in_if_block405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_if_block405	= { FOLLOW_46_in_if_block405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_else_block416  */
static	ANTLR3_BITWORD FOLLOW_55_in_else_block416_bits[]	= { ANTLR3_UINT64_LIT(0x2114000200001010) };
static  ANTLR3_BITSET_LIST FOLLOW_55_in_else_block416	= { FOLLOW_55_in_else_block416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_52_in_else_block419  */
static	ANTLR3_BITWORD FOLLOW_52_in_else_block419_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_52_in_else_block419	= { FOLLOW_52_in_else_block419_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_boolean_expression_in_else_block421  */
static	ANTLR3_BITWORD FOLLOW_boolean_expression_in_else_block421_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_boolean_expression_in_else_block421	= { FOLLOW_boolean_expression_in_else_block421_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_59_in_else_block423  */
static	ANTLR3_BITWORD FOLLOW_59_in_else_block423_bits[]	= { ANTLR3_UINT64_LIT(0x2104000200001010) };
static  ANTLR3_BITSET_LIST FOLLOW_59_in_else_block423	= { FOLLOW_59_in_else_block423_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_list_in_else_block427  */
static	ANTLR3_BITWORD FOLLOW_statement_list_in_else_block427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_list_in_else_block427	= { FOLLOW_statement_list_in_else_block427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variable_declaration_in_declaration_list460  */
static	ANTLR3_BITWORD FOLLOW_variable_declaration_in_declaration_list460_bits[]	= { ANTLR3_UINT64_LIT(0x00000000002004A0) };
static  ANTLR3_BITSET_LIST FOLLOW_variable_declaration_in_declaration_list460	= { FOLLOW_variable_declaration_in_declaration_list460_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_split_in_declaration_list462  */
static	ANTLR3_BITWORD FOLLOW_declaration_split_in_declaration_list462_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000501002) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_split_in_declaration_list462	= { FOLLOW_declaration_split_in_declaration_list462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_list_in_declaration_list464  */
static	ANTLR3_BITWORD FOLLOW_declaration_list_in_declaration_list464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_list_in_declaration_list464	= { FOLLOW_declaration_list_in_declaration_list464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedure_in_declaration_list471  */
static	ANTLR3_BITWORD FOLLOW_procedure_in_declaration_list471_bits[]	= { ANTLR3_UINT64_LIT(0x00000000002004A0) };
static  ANTLR3_BITSET_LIST FOLLOW_procedure_in_declaration_list471	= { FOLLOW_procedure_in_declaration_list471_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_in_declaration_list475  */
static	ANTLR3_BITWORD FOLLOW_function_in_declaration_list475_bits[]	= { ANTLR3_UINT64_LIT(0x00000000002004A0) };
static  ANTLR3_BITSET_LIST FOLLOW_function_in_declaration_list475	= { FOLLOW_function_in_declaration_list475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_split_in_declaration_list478  */
static	ANTLR3_BITWORD FOLLOW_declaration_split_in_declaration_list478_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000501002) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_split_in_declaration_list478	= { FOLLOW_declaration_split_in_declaration_list478_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_list_in_declaration_list480  */
static	ANTLR3_BITWORD FOLLOW_declaration_list_in_declaration_list480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_list_in_declaration_list480	= { FOLLOW_declaration_list_in_declaration_list480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_variable_declaration494  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_variable_declaration494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_variable_declaration494	= { FOLLOW_identifier_in_variable_declaration494_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WASA_in_variable_declaration496  */
static	ANTLR3_BITWORD FOLLOW_WASA_in_variable_declaration496_bits[]	= { ANTLR3_UINT64_LIT(0x0428000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_WASA_in_variable_declaration496	= { FOLLOW_WASA_in_variable_declaration496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_variable_declaration498  */
static	ANTLR3_BITWORD FOLLOW_type_in_variable_declaration498_bits[]	= { ANTLR3_UINT64_LIT(0x1040000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_variable_declaration498	= { FOLLOW_type_in_variable_declaration498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_variable_declaration501  */
static	ANTLR3_BITWORD FOLLOW_54_in_variable_declaration501_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_54_in_variable_declaration501	= { FOLLOW_54_in_variable_declaration501_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_variable_declaration503  */
static	ANTLR3_BITWORD FOLLOW_expression_in_variable_declaration503_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_variable_declaration503	= { FOLLOW_expression_in_variable_declaration503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_variable_declaration507  */
static	ANTLR3_BITWORD FOLLOW_60_in_variable_declaration507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_60_in_variable_declaration507	= { FOLLOW_60_in_variable_declaration507_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_61_in_input_statement518  */
static	ANTLR3_BITWORD FOLLOW_61_in_input_statement518_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_61_in_input_statement518	= { FOLLOW_61_in_input_statement518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lvalue_in_input_statement520  */
static	ANTLR3_BITWORD FOLLOW_lvalue_in_input_statement520_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_lvalue_in_input_statement520	= { FOLLOW_lvalue_in_input_statement520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_input_statement522  */
static	ANTLR3_BITWORD FOLLOW_42_in_input_statement522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_input_statement522	= { FOLLOW_42_in_input_statement522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_spoke_statement532  */
static	ANTLR3_BITWORD FOLLOW_expression_in_spoke_statement532_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_spoke_statement532	= { FOLLOW_expression_in_spoke_statement532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPOKE_in_spoke_statement534  */
static	ANTLR3_BITWORD FOLLOW_SPOKE_in_spoke_statement534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SPOKE_in_spoke_statement534	= { FOLLOW_SPOKE_in_spoke_statement534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_additive_expr_in_expression544  */
static	ANTLR3_BITWORD FOLLOW_additive_expr_in_expression544_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_additive_expr_in_expression544	= { FOLLOW_additive_expr_in_expression544_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lvalue_in_assignment_expr555  */
static	ANTLR3_BITWORD FOLLOW_lvalue_in_assignment_expr555_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_lvalue_in_assignment_expr555	= { FOLLOW_lvalue_in_assignment_expr555_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BECAME_in_assignment_expr557  */
static	ANTLR3_BITWORD FOLLOW_BECAME_in_assignment_expr557_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_BECAME_in_assignment_expr557	= { FOLLOW_BECAME_in_assignment_expr557_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_assignment_expr559  */
static	ANTLR3_BITWORD FOLLOW_expression_in_assignment_expr559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_assignment_expr559	= { FOLLOW_expression_in_assignment_expr559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_lvalue570  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_lvalue570_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_lvalue570	= { FOLLOW_identifier_in_lvalue570_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_lvalue573  */
static	ANTLR3_BITWORD FOLLOW_43_in_lvalue573_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_lvalue573	= { FOLLOW_43_in_lvalue573_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_lvalue575  */
static	ANTLR3_BITWORD FOLLOW_expression_in_lvalue575_bits[]	= { ANTLR3_UINT64_LIT(0x0200000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_lvalue575	= { FOLLOW_expression_in_lvalue575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_57_in_lvalue577  */
static	ANTLR3_BITWORD FOLLOW_57_in_lvalue577_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_57_in_lvalue577	= { FOLLOW_57_in_lvalue577_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicactive_expr_in_additive_expr590  */
static	ANTLR3_BITWORD FOLLOW_multiplicactive_expr_in_additive_expr590_bits[]	= { ANTLR3_UINT64_LIT(0x0000000180000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicactive_expr_in_additive_expr590	= { FOLLOW_multiplicactive_expr_in_additive_expr590_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_additive_expr593  */
static	ANTLR3_BITWORD FOLLOW_set_in_additive_expr593_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_additive_expr593	= { FOLLOW_set_in_additive_expr593_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicactive_expr_in_additive_expr599  */
static	ANTLR3_BITWORD FOLLOW_multiplicactive_expr_in_additive_expr599_bits[]	= { ANTLR3_UINT64_LIT(0x0000000180000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicactive_expr_in_additive_expr599	= { FOLLOW_multiplicactive_expr_in_additive_expr599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitwise_expr_in_multiplicactive_expr612  */
static	ANTLR3_BITWORD FOLLOW_bitwise_expr_in_multiplicactive_expr612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000448000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitwise_expr_in_multiplicactive_expr612	= { FOLLOW_bitwise_expr_in_multiplicactive_expr612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_multiplicactive_expr615  */
static	ANTLR3_BITWORD FOLLOW_set_in_multiplicactive_expr615_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_multiplicactive_expr615	= { FOLLOW_set_in_multiplicactive_expr615_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitwise_expr_in_multiplicactive_expr623  */
static	ANTLR3_BITWORD FOLLOW_bitwise_expr_in_multiplicactive_expr623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000448000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitwise_expr_in_multiplicactive_expr623	= { FOLLOW_bitwise_expr_in_multiplicactive_expr623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unary_expr_in_bitwise_expr636  */
static	ANTLR3_BITWORD FOLLOW_unary_expr_in_bitwise_expr636_bits[]	= { ANTLR3_UINT64_LIT(0x4000100020000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unary_expr_in_bitwise_expr636	= { FOLLOW_unary_expr_in_bitwise_expr636_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_bitwise_expr639  */
static	ANTLR3_BITWORD FOLLOW_set_in_bitwise_expr639_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_bitwise_expr639	= { FOLLOW_set_in_bitwise_expr639_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unary_expr_in_bitwise_expr647  */
static	ANTLR3_BITWORD FOLLOW_unary_expr_in_bitwise_expr647_bits[]	= { ANTLR3_UINT64_LIT(0x4000100020000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unary_expr_in_bitwise_expr647	= { FOLLOW_unary_expr_in_bitwise_expr647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_unary_expr660  */
static	ANTLR3_BITWORD FOLLOW_set_in_unary_expr660_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_unary_expr660	= { FOLLOW_set_in_unary_expr660_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unary_expr_in_unary_expr676  */
static	ANTLR3_BITWORD FOLLOW_unary_expr_in_unary_expr676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unary_expr_in_unary_expr676	= { FOLLOW_unary_expr_in_unary_expr676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constant_in_unary_expr681  */
static	ANTLR3_BITWORD FOLLOW_constant_in_unary_expr681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constant_in_unary_expr681	= { FOLLOW_constant_in_unary_expr681_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lvalue_in_unary_expr686  */
static	ANTLR3_BITWORD FOLLOW_lvalue_in_unary_expr686_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lvalue_in_unary_expr686	= { FOLLOW_lvalue_in_unary_expr686_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_unary_expr691  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_unary_expr691_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_unary_expr691	= { FOLLOW_LPAREN_in_unary_expr691_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_additive_expr_in_unary_expr693  */
static	ANTLR3_BITWORD FOLLOW_additive_expr_in_unary_expr693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_additive_expr_in_unary_expr693	= { FOLLOW_additive_expr_in_unary_expr693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_unary_expr695  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_unary_expr695_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_unary_expr695	= { FOLLOW_RPAREN_in_unary_expr695_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_single_boolean_expression_in_boolean_expression706  */
static	ANTLR3_BITWORD FOLLOW_single_boolean_expression_in_boolean_expression706_bits[]	= { ANTLR3_UINT64_LIT(0x8000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_single_boolean_expression_in_boolean_expression706	= { FOLLOW_single_boolean_expression_in_boolean_expression706_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_boolean_expression709  */
static	ANTLR3_BITWORD FOLLOW_set_in_boolean_expression709_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_boolean_expression709	= { FOLLOW_set_in_boolean_expression709_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_single_boolean_expression_in_boolean_expression717  */
static	ANTLR3_BITWORD FOLLOW_single_boolean_expression_in_boolean_expression717_bits[]	= { ANTLR3_UINT64_LIT(0x8000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_single_boolean_expression_in_boolean_expression717	= { FOLLOW_single_boolean_expression_in_boolean_expression717_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_single_boolean_expression732  */
static	ANTLR3_BITWORD FOLLOW_expression_in_single_boolean_expression732_bits[]	= { ANTLR3_UINT64_LIT(0x000003E004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_single_boolean_expression732	= { FOLLOW_expression_in_single_boolean_expression732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_single_boolean_expression734  */
static	ANTLR3_BITWORD FOLLOW_set_in_single_boolean_expression734_bits[]	= { ANTLR3_UINT64_LIT(0x000000018200B100), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_single_boolean_expression734	= { FOLLOW_set_in_single_boolean_expression734_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_single_boolean_expression759  */
static	ANTLR3_BITWORD FOLLOW_expression_in_single_boolean_expression759_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_single_boolean_expression759	= { FOLLOW_expression_in_single_boolean_expression759_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LETTER_in_identifier770  */
static	ANTLR3_BITWORD FOLLOW_LETTER_in_identifier770_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_LETTER_in_identifier770	= { FOLLOW_LETTER_in_identifier770_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_synpred1_MAlice453  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_synpred1_MAlice453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_synpred1_MAlice453	= { FOLLOW_identifier_in_synpred1_MAlice453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WASA_in_synpred1_MAlice455  */
static	ANTLR3_BITWORD FOLLOW_WASA_in_synpred1_MAlice455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WASA_in_synpred1_MAlice455	= { FOLLOW_WASA_in_synpred1_MAlice455_bits, 1	};



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 26:4: ( declaration_argument ',' )*
 */
static const ANTLR3_INT32 dfa3_eot[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa3_eof[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa3_min[6] =
    {
	51, 12, 10, 10, -1, -1
    };
static const ANTLR3_INT32 dfa3_max[6] =
    {
	58, 12, 45, 45, -1, -1
    };
static const ANTLR3_INT32 dfa3_accept[6] =
    {
	-1, -1, -1, -1, 2, 1
    };
static const ANTLR3_INT32 dfa3_special[6] =
    {
	-1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa3_T_empty	    NULL

static const ANTLR3_INT32 dfa3_T0[] =
    {
	2
    };

static const ANTLR3_INT32 dfa3_T1[] =
    {
	5, -1, 3, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3
    };

static const ANTLR3_INT32 dfa3_T2[] =
    {
	1, -1, 1, -1, -1, -1, -1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa3_transitions[] =
{
    dfa3_T2, dfa3_T0, dfa3_T1, dfa3_T1, NULL, NULL
};

//static void
//dfaError(pMAliceParser ctx)
//{
//    DBG->recognitionException(DBG, EXCEPTION);
//}

/* Declare tracking structure for Cyclic DFA 3
 */
static
ANTLR3_CYCLIC_DFA cdfa3
    =	{
	    3,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 26:4: ( declaration_argument ',' )*",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa3_eot,	    /* EOT table			    */
	    dfa3_eof,	    /* EOF table			    */
	    dfa3_min,	    /* Minimum tokens for each state    */
	    dfa3_max,	    /* Maximum tokens for each state    */
	    dfa3_accept,	/* Accept table			    */
	    dfa3_special,	/* Special transition states	    */
	    dfa3_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 3
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    41:11: ( declaration_list )?
 */
static const ANTLR3_INT32 dfa5_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa5_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa5_min[5] =
    {
	4, 6, -1, -1, 6
    };
static const ANTLR3_INT32 dfa5_max[5] =
    {
	61, 45, -1, -1, 45
    };
static const ANTLR3_INT32 dfa5_accept[5] =
    {
	-1, -1, 1, 2, -1
    };
static const ANTLR3_INT32 dfa5_special[5] =
    {
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa5_T_empty	    NULL

static const ANTLR3_INT32 dfa5_T0[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 2, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, 3, -1, -1, -1, 
	-1, 3
    };

static const ANTLR3_INT32 dfa5_T1[] =
    {
	3, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, -1, 4
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa5_transitions[] =
{
    dfa5_T0, dfa5_T1, NULL, NULL, dfa5_T1
};

//static void
//dfaError(pMAliceParser ctx)
//{
//    DBG->recognitionException(DBG, EXCEPTION);
//}

/* Declare tracking structure for Cyclic DFA 5
 */
static
ANTLR3_CYCLIC_DFA cdfa5
    =	{
	    5,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"41:11: ( declaration_list )?",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa5_eot,	    /* EOT table			    */
	    dfa5_eof,	    /* EOF table			    */
	    dfa5_min,	    /* Minimum tokens for each state    */
	    dfa5_max,	    /* Maximum tokens for each state    */
	    dfa5_accept,	/* Accept table			    */
	    dfa5_special,	/* Special transition states	    */
	    dfa5_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 5
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    97:65: ( declaration_list )?
 */
static const ANTLR3_INT32 dfa12_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa12_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa12_min[5] =
    {
	4, 6, -1, -1, 6
    };
static const ANTLR3_INT32 dfa12_max[5] =
    {
	61, 45, -1, -1, 45
    };
static const ANTLR3_INT32 dfa12_accept[5] =
    {
	-1, -1, 1, 2, -1
    };
static const ANTLR3_INT32 dfa12_special[5] =
    {
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa12_T_empty	    NULL

static const ANTLR3_INT32 dfa12_T0[] =
    {
	3, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, -1, 4
    };

static const ANTLR3_INT32 dfa12_T1[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 2, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, 3, -1, -1, -1, 
	-1, 3
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa12_transitions[] =
{
    dfa12_T1, dfa12_T0, NULL, NULL, dfa12_T0
};

//static void
//dfaError(pMAliceParser ctx)
//{
//    DBG->recognitionException(DBG, EXCEPTION);
//}

/* Declare tracking structure for Cyclic DFA 12
 */
static
ANTLR3_CYCLIC_DFA cdfa12
    =	{
	    12,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"97:65: ( declaration_list )?",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa12_eot,	    /* EOT table			    */
	    dfa12_eof,	    /* EOF table			    */
	    dfa12_min,	    /* Minimum tokens for each state    */
	    dfa12_max,	    /* Maximum tokens for each state    */
	    dfa12_accept,	/* Accept table			    */
	    dfa12_special,	/* Special transition states	    */
	    dfa12_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 12
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    98:45: ( declaration_list )?
 */
static const ANTLR3_INT32 dfa14_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa14_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa14_min[5] =
    {
	4, 6, -1, -1, 6
    };
static const ANTLR3_INT32 dfa14_max[5] =
    {
	61, 45, -1, -1, 45
    };
static const ANTLR3_INT32 dfa14_accept[5] =
    {
	-1, -1, 1, 2, -1
    };
static const ANTLR3_INT32 dfa14_special[5] =
    {
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa14_T_empty	    NULL

static const ANTLR3_INT32 dfa14_T0[] =
    {
	3, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, -1, 4
    };

static const ANTLR3_INT32 dfa14_T1[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 2, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, 3, -1, -1, -1, 
	-1, 3
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa14_transitions[] =
{
    dfa14_T1, dfa14_T0, NULL, NULL, dfa14_T0
};

//static void
//dfaError(pMAliceParser ctx)
//{
//    DBG->recognitionException(DBG, EXCEPTION);
//}

/* Declare tracking structure for Cyclic DFA 14
 */
static
ANTLR3_CYCLIC_DFA cdfa14
    =	{
	    14,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"98:45: ( declaration_list )?",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa14_eot,	    /* EOT table			    */
	    dfa14_eof,	    /* EOF table			    */
	    dfa14_min,	    /* Minimum tokens for each state    */
	    dfa14_max,	    /* Maximum tokens for each state    */
	    dfa14_accept,	/* Accept table			    */
	    dfa14_special,	/* Special transition states	    */
	    dfa14_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 14
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start type
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:10:1: type : ( 'number' | 'letter' | 'sentence' );
 */
static void
type(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"type");
    incRuleLevel();
    DBG->location(DBG, 10, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:10:7: ( 'number' | 'letter' | 'sentence' )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:
        {
            DBG->location(DBG, 10, 7);
            if ( LA(1) == 51 || LA(1) == 53 || LA(1) == 58 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                DBG->recognitionException(DBG, EXCEPTION);
                goto ruletypeEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletypeEx; /* Prevent compiler warnings */
    ruletypeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 13, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"type");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end type */

/**
 * $ANTLR start constant
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:15:1: constant : ( NUMBER_LITERAL | CHARACTER_LITERAL );
 */
static void
constant(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"constant");
    incRuleLevel();
    DBG->location(DBG, 15, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:15:9: ( NUMBER_LITERAL | CHARACTER_LITERAL )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:
        {
            DBG->location(DBG, 15, 9);
            if ( LA(1) == CHARACTER_LITERAL || LA(1) == NUMBER_LITERAL )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                DBG->recognitionException(DBG, EXCEPTION);
                goto ruleconstantEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstantEx; /* Prevent compiler warnings */
    ruleconstantEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 17, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"constant");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end constant */

/**
 * $ANTLR start program
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:20:1: program : ( function | procedure )+ ;
 */
static void
program(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"program");
    incRuleLevel();
    DBG->location(DBG, 20, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:20:9: ( ( function | procedure )+ )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:20:11: ( function | procedure )+
        {
            DBG->location(DBG, 20, 11);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:20:11: ( function | procedure )+
            {
                int cnt1=0;
                DBG->enterSubRule(DBG, 1);


                for (;;)
                {
                    int alt1=3;
            	DBG->enterDecision(DBG, 1);

            	switch ( LA(1) )
            	{
            	case THEROOM:
            		{
            			alt1=1;
            		}
            	    break;
            	case THELOOKINGGLASS:
            		{
            			alt1=2;
            		}
            	    break;

            	}

            	DBG->exitDecision(DBG, 1);

            	switch (alt1)
            	{
            	    case 1:
            	        DBG->enterAlt(DBG, 1);

            	        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:20:12: function
            	        {
            	            DBG->location(DBG, 20, 12);
            	            FOLLOWPUSH(FOLLOW_function_in_program92);
            	            function(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleprogramEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"program");
            	                decRuleLevel();
            	                return ;
            	            }


            	        }
            	        break;
            	    case 2:
            	        DBG->enterAlt(DBG, 2);

            	        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:20:21: procedure
            	        {
            	            DBG->location(DBG, 20, 21);
            	            FOLLOWPUSH(FOLLOW_procedure_in_program94);
            	            procedure(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleprogramEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"program");
            	                decRuleLevel();
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		DBG->recognitionException(DBG, EXCEPTION);

            		goto ruleprogramEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
                DBG->exitSubRule(DBG, 1);

            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 20, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"program");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end program */

/**
 * $ANTLR start function
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:22:1: function : THEROOM identifier LPAREN ( declaration_argument_list )? RPAREN 'contained a' type block_unit ;
 */
static void
function(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"function");
    incRuleLevel();
    DBG->location(DBG, 22, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:22:9: ( THEROOM identifier LPAREN ( declaration_argument_list )? RPAREN 'contained a' type block_unit )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:22:11: THEROOM identifier LPAREN ( declaration_argument_list )? RPAREN 'contained a' type block_unit
        {
            DBG->location(DBG, 22, 11);
             MATCHT(THEROOM, &FOLLOW_THEROOM_in_function103);
            if  (HASEXCEPTION())
            {
                goto rulefunctionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"function");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 22, 19);
            FOLLOWPUSH(FOLLOW_identifier_in_function105);
            identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"function");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 22, 30);
             MATCHT(LPAREN, &FOLLOW_LPAREN_in_function107);
            if  (HASEXCEPTION())
            {
                goto rulefunctionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"function");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 22, 37);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:22:37: ( declaration_argument_list )?
            {
                int alt2=2;
                DBG->enterSubRule(DBG, 2);
                DBG->enterDecision(DBG, 2);

                switch ( LA(1) )
                {
                    case 51:
                    case 53:
                    case 58:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                DBG->exitDecision(DBG, 2);

                switch (alt2)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:22:37: declaration_argument_list
            	    {
            	        DBG->location(DBG, 22, 37);
            	        FOLLOWPUSH(FOLLOW_declaration_argument_list_in_function109);
            	        declaration_argument_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"function");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

                }
                DBG->exitSubRule(DBG, 2);

            }
            DBG->location(DBG, 22, 64);
             MATCHT(RPAREN, &FOLLOW_RPAREN_in_function112);
            if  (HASEXCEPTION())
            {
                goto rulefunctionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"function");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 22, 71);
             MATCHT(48, &FOLLOW_48_in_function114);
            if  (HASEXCEPTION())
            {
                goto rulefunctionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"function");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 22, 85);
            FOLLOWPUSH(FOLLOW_type_in_function116);
            type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"function");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 22, 90);
            FOLLOWPUSH(FOLLOW_block_unit_in_function118);
            block_unit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"function");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionEx; /* Prevent compiler warnings */
    rulefunctionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 22, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"function");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end function */

/**
 * $ANTLR start declaration_argument_list
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:25:1: declaration_argument_list : ( declaration_argument ',' )* declaration_argument ;
 */
static void
declaration_argument_list(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"declaration_argument_list");
    incRuleLevel();
    DBG->location(DBG, 25, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:26:2: ( ( declaration_argument ',' )* declaration_argument )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:26:4: ( declaration_argument ',' )* declaration_argument
        {
            DBG->location(DBG, 26, 4);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:26:4: ( declaration_argument ',' )*

            DBG->enterSubRule(DBG, 3);

            for (;;)
            {
                int alt3=2;
                DBG->enterDecision(DBG, 3);

                alt3 = cdfa3.predict(ctx, RECOGNIZER, ISTREAM, &cdfa3);
                if  (HASEXCEPTION())
                {
                	DBG->recognitionException(DBG, EXCEPTION);
                    goto ruledeclaration_argument_listEx;
                }
                if  (HASEXCEPTION())
                {
                    goto ruledeclaration_argument_listEx;
                }
                if (HASFAILED())
                {
                    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_argument_list");
                    decRuleLevel();
                    return ;
                }

                DBG->exitDecision(DBG, 3);

                switch (alt3)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:26:5: declaration_argument ','
            	    {
            	        DBG->location(DBG, 26, 5);
            	        FOLLOWPUSH(FOLLOW_declaration_argument_in_declaration_argument_list129);
            	        declaration_argument(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclaration_argument_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_argument_list");
            	            decRuleLevel();
            	            return ;
            	        }

            	        DBG->location(DBG, 26, 26);
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_declaration_argument_list131);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledeclaration_argument_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_argument_list");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */
            DBG->exitSubRule(DBG, 3);

            DBG->location(DBG, 26, 32);
            FOLLOWPUSH(FOLLOW_declaration_argument_in_declaration_argument_list135);
            declaration_argument(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_argument_listEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_argument_list");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclaration_argument_listEx; /* Prevent compiler warnings */
    ruledeclaration_argument_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 27, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_argument_list");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end declaration_argument_list */

/**
 * $ANTLR start procedure
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:28:1: procedure : THELOOKINGGLASS identifier LPAREN ( declaration_argument_list )? RPAREN block_unit ;
 */
static void
procedure(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"procedure");
    incRuleLevel();
    DBG->location(DBG, 28, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:29:2: ( THELOOKINGGLASS identifier LPAREN ( declaration_argument_list )? RPAREN block_unit )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:29:4: THELOOKINGGLASS identifier LPAREN ( declaration_argument_list )? RPAREN block_unit
        {
            DBG->location(DBG, 29, 4);
             MATCHT(THELOOKINGGLASS, &FOLLOW_THELOOKINGGLASS_in_procedure145);
            if  (HASEXCEPTION())
            {
                goto ruleprocedureEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"procedure");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 29, 20);
            FOLLOWPUSH(FOLLOW_identifier_in_procedure147);
            identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprocedureEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"procedure");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 29, 31);
             MATCHT(LPAREN, &FOLLOW_LPAREN_in_procedure149);
            if  (HASEXCEPTION())
            {
                goto ruleprocedureEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"procedure");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 29, 38);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:29:38: ( declaration_argument_list )?
            {
                int alt4=2;
                DBG->enterSubRule(DBG, 4);
                DBG->enterDecision(DBG, 4);

                switch ( LA(1) )
                {
                    case 51:
                    case 53:
                    case 58:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                DBG->exitDecision(DBG, 4);

                switch (alt4)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:29:38: declaration_argument_list
            	    {
            	        DBG->location(DBG, 29, 38);
            	        FOLLOWPUSH(FOLLOW_declaration_argument_list_in_procedure151);
            	        declaration_argument_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedureEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"procedure");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

                }
                DBG->exitSubRule(DBG, 4);

            }
            DBG->location(DBG, 29, 65);
             MATCHT(RPAREN, &FOLLOW_RPAREN_in_procedure154);
            if  (HASEXCEPTION())
            {
                goto ruleprocedureEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"procedure");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 29, 72);
            FOLLOWPUSH(FOLLOW_block_unit_in_procedure156);
            block_unit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprocedureEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"procedure");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprocedureEx; /* Prevent compiler warnings */
    ruleprocedureEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 30, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"procedure");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end procedure */

/**
 * $ANTLR start declaration_argument
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:33:1: declaration_argument : type identifier ;
 */
static void
declaration_argument(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"declaration_argument");
    incRuleLevel();
    DBG->location(DBG, 33, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:34:2: ( type identifier )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:34:4: type identifier
        {
            DBG->location(DBG, 34, 4);
            FOLLOWPUSH(FOLLOW_type_in_declaration_argument170);
            type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_argumentEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_argument");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 34, 9);
            FOLLOWPUSH(FOLLOW_identifier_in_declaration_argument172);
            identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledeclaration_argumentEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_argument");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclaration_argumentEx; /* Prevent compiler warnings */
    ruledeclaration_argumentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 35, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_argument");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end declaration_argument */

/**
 * $ANTLR start block_unit
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:37:1: block_unit options {k=2; } : OPENED ( declaration_list )? statement_list CLOSED ;
 */
static void
block_unit(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"block_unit");
    incRuleLevel();
    DBG->location(DBG, 37, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:41:2: ( OPENED ( declaration_list )? statement_list CLOSED )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:41:4: OPENED ( declaration_list )? statement_list CLOSED
        {
            DBG->location(DBG, 41, 4);
             MATCHT(OPENED, &FOLLOW_OPENED_in_block_unit196);
            if  (HASEXCEPTION())
            {
                goto ruleblock_unitEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"block_unit");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 41, 11);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:41:11: ( declaration_list )?
            {
                int alt5=2;
                DBG->enterSubRule(DBG, 5);
                DBG->enterDecision(DBG, 5);

                alt5 = cdfa5.predict(ctx, RECOGNIZER, ISTREAM, &cdfa5);
                if  (HASEXCEPTION())
                {
                	DBG->recognitionException(DBG, EXCEPTION);
                    goto ruleblock_unitEx;
                }
                if  (HASEXCEPTION())
                {
                    goto ruleblock_unitEx;
                }
                if (HASFAILED())
                {
                    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"block_unit");
                    decRuleLevel();
                    return ;
                }

                DBG->exitDecision(DBG, 5);

                switch (alt5)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:41:12: declaration_list
            	    {
            	        DBG->location(DBG, 41, 12);
            	        FOLLOWPUSH(FOLLOW_declaration_list_in_block_unit199);
            	        declaration_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleblock_unitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"block_unit");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

                }
                DBG->exitSubRule(DBG, 5);

            }
            DBG->location(DBG, 41, 31);
            FOLLOWPUSH(FOLLOW_statement_list_in_block_unit203);
            statement_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleblock_unitEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"block_unit");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 41, 46);
             MATCHT(CLOSED, &FOLLOW_CLOSED_in_block_unit205);
            if  (HASEXCEPTION())
            {
                goto ruleblock_unitEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"block_unit");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblock_unitEx; /* Prevent compiler warnings */
    ruleblock_unitEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 41, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"block_unit");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end block_unit */

/**
 * $ANTLR start proc_func_invocation
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:44:1: proc_func_invocation : identifier LPAREN ( proc_func_invocation_argument_list )? RPAREN ;
 */
static void
proc_func_invocation(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation");
    incRuleLevel();
    DBG->location(DBG, 44, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:45:2: ( identifier LPAREN ( proc_func_invocation_argument_list )? RPAREN )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:45:4: identifier LPAREN ( proc_func_invocation_argument_list )? RPAREN
        {
            DBG->location(DBG, 45, 4);
            FOLLOWPUSH(FOLLOW_identifier_in_proc_func_invocation215);
            identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproc_func_invocationEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 45, 15);
             MATCHT(LPAREN, &FOLLOW_LPAREN_in_proc_func_invocation217);
            if  (HASEXCEPTION())
            {
                goto ruleproc_func_invocationEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 45, 22);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:45:22: ( proc_func_invocation_argument_list )?
            {
                int alt6=2;
                DBG->enterSubRule(DBG, 6);
                DBG->enterDecision(DBG, 6);

                switch ( LA(1) )
                {
                    case CHARACTER_LITERAL:
                    case NUMBER_LITERAL:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                DBG->exitDecision(DBG, 6);

                switch (alt6)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:45:22: proc_func_invocation_argument_list
            	    {
            	        DBG->location(DBG, 45, 22);
            	        FOLLOWPUSH(FOLLOW_proc_func_invocation_argument_list_in_proc_func_invocation219);
            	        proc_func_invocation_argument_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleproc_func_invocationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

                }
                DBG->exitSubRule(DBG, 6);

            }
            DBG->location(DBG, 45, 58);
             MATCHT(RPAREN, &FOLLOW_RPAREN_in_proc_func_invocation222);
            if  (HASEXCEPTION())
            {
                goto ruleproc_func_invocationEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleproc_func_invocationEx; /* Prevent compiler warnings */
    ruleproc_func_invocationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 46, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end proc_func_invocation */

/**
 * $ANTLR start proc_func_invocation_argument_list
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:49:1: proc_func_invocation_argument_list : ( constant ',' )* constant ;
 */
static void
proc_func_invocation_argument_list(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation_argument_list");
    incRuleLevel();
    DBG->location(DBG, 49, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:50:2: ( ( constant ',' )* constant )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:50:4: ( constant ',' )* constant
        {
            DBG->location(DBG, 50, 4);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:50:4: ( constant ',' )*

            DBG->enterSubRule(DBG, 7);

            for (;;)
            {
                int alt7=2;
                DBG->enterDecision(DBG, 7);

                switch ( LA(1) )
                {
                case CHARACTER_LITERAL:
                case NUMBER_LITERAL:
                	{
                		switch ( LA(2) )
                		{
                		case COMMA:
                			{
                				alt7=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                DBG->exitDecision(DBG, 7);

                switch (alt7)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:50:5: constant ','
            	    {
            	        DBG->location(DBG, 50, 5);
            	        FOLLOWPUSH(FOLLOW_constant_in_proc_func_invocation_argument_list235);
            	        constant(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleproc_func_invocation_argument_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation_argument_list");
            	            decRuleLevel();
            	            return ;
            	        }

            	        DBG->location(DBG, 50, 14);
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_proc_func_invocation_argument_list237);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleproc_func_invocation_argument_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation_argument_list");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */
            DBG->exitSubRule(DBG, 7);

            DBG->location(DBG, 50, 20);
            FOLLOWPUSH(FOLLOW_constant_in_proc_func_invocation_argument_list241);
            constant(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproc_func_invocation_argument_listEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation_argument_list");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleproc_func_invocation_argument_listEx; /* Prevent compiler warnings */
    ruleproc_func_invocation_argument_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 51, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"proc_func_invocation_argument_list");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end proc_func_invocation_argument_list */

/**
 * $ANTLR start assignment
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:54:1: assignment : lvalue BECAME expression ;
 */
static void
assignment(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"assignment");
    incRuleLevel();
    DBG->location(DBG, 54, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:55:2: ( lvalue BECAME expression )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:55:4: lvalue BECAME expression
        {
            DBG->location(DBG, 55, 4);
            FOLLOWPUSH(FOLLOW_lvalue_in_assignment253);
            lvalue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"assignment");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 55, 11);
             MATCHT(BECAME, &FOLLOW_BECAME_in_assignment255);
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"assignment");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 55, 18);
            FOLLOWPUSH(FOLLOW_expression_in_assignment257);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"assignment");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignmentEx; /* Prevent compiler warnings */
    ruleassignmentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 56, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"assignment");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end assignment */

/**
 * $ANTLR start declaration_split
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:60:1: declaration_split : ( COMMA | THEN | AND | BUT ) ;
 */
static void
declaration_split(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"declaration_split");
    incRuleLevel();
    DBG->location(DBG, 60, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:60:20: ( ( COMMA | THEN | AND | BUT ) )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:
        {
            DBG->location(DBG, 60, 20);
            if ( LA(1) == AND || LA(1) == BUT || LA(1) == COMMA || LA(1) == THEN )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                DBG->recognitionException(DBG, EXCEPTION);
                goto ruledeclaration_splitEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledeclaration_splitEx; /* Prevent compiler warnings */
    ruledeclaration_splitEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 60, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_split");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end declaration_split */

/**
 * $ANTLR start split
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:61:1: split : '.' ;
 */
static void
split(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"split");
    incRuleLevel();
    DBG->location(DBG, 61, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:61:7: ( '.' )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:61:9: '.'
        {
            DBG->location(DBG, 61, 9);
             MATCHT(33, &FOLLOW_33_in_split291);
            if  (HASEXCEPTION())
            {
                goto rulesplitEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"split");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesplitEx; /* Prevent compiler warnings */
    rulesplitEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 61, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"split");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end split */

/**
 * $ANTLR start statement_component
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:63:1: statement_component : ( return_statement | while_loop | if_block | assignment_expr | input_statement | '.' );
 */
static void
statement_component(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"statement_component");
    incRuleLevel();
    DBG->location(DBG, 63, );

    {
        {
            //  /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:64:2: ( return_statement | while_loop | if_block | assignment_expr | input_statement | '.' )

            ANTLR3_UINT32 alt8;

            alt8=6;

            DBG->enterDecision(DBG, 8);

            switch ( LA(1) )
            {
            case ALICEFOUND:
            	{
            		alt8=1;
            	}
                break;
            case 50:
            	{
            		alt8=2;
            	}
                break;
            case 56:
            	{
            		alt8=3;
            	}
                break;
            case LETTER:
            	{
            		alt8=4;
            	}
                break;
            case 61:
            	{
            		alt8=5;
            	}
                break;
            case 33:
            	{
            		alt8=6;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;
                DBG->recognitionException(DBG, EXCEPTION);


                goto rulestatement_componentEx;

            }

            DBG->exitDecision(DBG, 8);

            switch (alt8)
            {
        	case 1:
        	    DBG->enterAlt(DBG, 1);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:64:4: return_statement
        	    {
        	        DBG->location(DBG, 64, 4);
        	        FOLLOWPUSH(FOLLOW_return_statement_in_statement_component300);
        	        return_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatement_componentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_component");
        	            decRuleLevel();
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    DBG->enterAlt(DBG, 2);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:65:4: while_loop
        	    {
        	        DBG->location(DBG, 65, 4);
        	        FOLLOWPUSH(FOLLOW_while_loop_in_statement_component305);
        	        while_loop(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatement_componentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_component");
        	            decRuleLevel();
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    DBG->enterAlt(DBG, 3);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:66:4: if_block
        	    {
        	        DBG->location(DBG, 66, 4);
        	        FOLLOWPUSH(FOLLOW_if_block_in_statement_component310);
        	        if_block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatement_componentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_component");
        	            decRuleLevel();
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    DBG->enterAlt(DBG, 4);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:67:4: assignment_expr
        	    {
        	        DBG->location(DBG, 67, 4);
        	        FOLLOWPUSH(FOLLOW_assignment_expr_in_statement_component316);
        	        assignment_expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatement_componentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_component");
        	            decRuleLevel();
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    DBG->enterAlt(DBG, 5);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:68:4: input_statement
        	    {
        	        DBG->location(DBG, 68, 4);
        	        FOLLOWPUSH(FOLLOW_input_statement_in_statement_component321);
        	        input_statement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatement_componentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_component");
        	            decRuleLevel();
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    DBG->enterAlt(DBG, 6);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:69:4: '.'
        	    {
        	        DBG->location(DBG, 69, 4);
        	         MATCHT(33, &FOLLOW_33_in_statement_component326);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatement_componentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_component");
        	            decRuleLevel();
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatement_componentEx; /* Prevent compiler warnings */
    rulestatement_componentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 70, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_component");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end statement_component */

/**
 * $ANTLR start statement_list
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:71:1: statement_list : ( statement_component ) ( split statement_component )* ;
 */
static void
statement_list(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"statement_list");
    incRuleLevel();
    DBG->location(DBG, 71, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:72:2: ( ( statement_component ) ( split statement_component )* )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:72:4: ( statement_component ) ( split statement_component )*
        {
            DBG->location(DBG, 72, 4);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:72:4: ( statement_component )
            DBG->enterAlt(DBG, 1);

            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:72:5: statement_component
            {
                DBG->location(DBG, 72, 5);
                FOLLOWPUSH(FOLLOW_statement_component_in_statement_list337);
                statement_component(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulestatement_listEx;
                }
                if (HASFAILED())
                {
                    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_list");
                    decRuleLevel();
                    return ;
                }


            }

            DBG->location(DBG, 72, 26);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:72:26: ( split statement_component )*

            DBG->enterSubRule(DBG, 9);

            for (;;)
            {
                int alt9=2;
                DBG->enterDecision(DBG, 9);

                switch ( LA(1) )
                {
                case 33:
                	{
                		alt9=1;
                	}
                    break;

                }

                DBG->exitDecision(DBG, 9);

                switch (alt9)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:72:27: split statement_component
            	    {
            	        DBG->location(DBG, 72, 27);
            	        FOLLOWPUSH(FOLLOW_split_in_statement_list341);
            	        split(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatement_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_list");
            	            decRuleLevel();
            	            return ;
            	        }

            	        DBG->location(DBG, 72, 33);
            	        FOLLOWPUSH(FOLLOW_statement_component_in_statement_list343);
            	        statement_component(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestatement_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_list");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */
            DBG->exitSubRule(DBG, 9);


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestatement_listEx; /* Prevent compiler warnings */
    rulestatement_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 73, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"statement_list");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end statement_list */

/**
 * $ANTLR start return_statement
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:77:1: return_statement : ALICEFOUND constant ;
 */
static void
return_statement(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"return_statement");
    incRuleLevel();
    DBG->location(DBG, 77, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:78:2: ( ALICEFOUND constant )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:78:4: ALICEFOUND constant
        {
            DBG->location(DBG, 78, 4);
             MATCHT(ALICEFOUND, &FOLLOW_ALICEFOUND_in_return_statement360);
            if  (HASEXCEPTION())
            {
                goto rulereturn_statementEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"return_statement");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 78, 15);
            FOLLOWPUSH(FOLLOW_constant_in_return_statement362);
            constant(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulereturn_statementEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"return_statement");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulereturn_statementEx; /* Prevent compiler warnings */
    rulereturn_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 79, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"return_statement");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end return_statement */

/**
 * $ANTLR start while_loop
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:81:1: while_loop : 'eventually' boolean_expression 'because' statement_list 'enough times' ;
 */
static void
while_loop(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"while_loop");
    incRuleLevel();
    DBG->location(DBG, 81, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:82:2: ( 'eventually' boolean_expression 'because' statement_list 'enough times' )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:82:4: 'eventually' boolean_expression 'because' statement_list 'enough times'
        {
            DBG->location(DBG, 82, 4);
             MATCHT(50, &FOLLOW_50_in_while_loop374);
            if  (HASEXCEPTION())
            {
                goto rulewhile_loopEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"while_loop");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 82, 17);
            FOLLOWPUSH(FOLLOW_boolean_expression_in_while_loop376);
            boolean_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhile_loopEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"while_loop");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 82, 36);
             MATCHT(47, &FOLLOW_47_in_while_loop378);
            if  (HASEXCEPTION())
            {
                goto rulewhile_loopEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"while_loop");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 82, 46);
            FOLLOWPUSH(FOLLOW_statement_list_in_while_loop380);
            statement_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhile_loopEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"while_loop");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 82, 61);
             MATCHT(49, &FOLLOW_49_in_while_loop382);
            if  (HASEXCEPTION())
            {
                goto rulewhile_loopEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"while_loop");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulewhile_loopEx; /* Prevent compiler warnings */
    rulewhile_loopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 83, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"while_loop");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end while_loop */

/**
 * $ANTLR start if_block
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:85:1: if_block : 'perhaps' boolean_expression 'so' statement_list ( else_block )* 'because Alice was unsure which' ;
 */
static void
if_block(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"if_block");
    incRuleLevel();
    DBG->location(DBG, 85, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:86:2: ( 'perhaps' boolean_expression 'so' statement_list ( else_block )* 'because Alice was unsure which' )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:86:4: 'perhaps' boolean_expression 'so' statement_list ( else_block )* 'because Alice was unsure which'
        {
            DBG->location(DBG, 86, 4);
             MATCHT(56, &FOLLOW_56_in_if_block394);
            if  (HASEXCEPTION())
            {
                goto ruleif_blockEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"if_block");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 86, 14);
            FOLLOWPUSH(FOLLOW_boolean_expression_in_if_block396);
            boolean_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleif_blockEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"if_block");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 86, 33);
             MATCHT(59, &FOLLOW_59_in_if_block398);
            if  (HASEXCEPTION())
            {
                goto ruleif_blockEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"if_block");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 86, 38);
            FOLLOWPUSH(FOLLOW_statement_list_in_if_block400);
            statement_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleif_blockEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"if_block");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 86, 53);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:86:53: ( else_block )*

            DBG->enterSubRule(DBG, 10);

            for (;;)
            {
                int alt10=2;
                DBG->enterDecision(DBG, 10);

                switch ( LA(1) )
                {
                case 55:
                	{
                		alt10=1;
                	}
                    break;

                }

                DBG->exitDecision(DBG, 10);

                switch (alt10)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:86:53: else_block
            	    {
            	        DBG->location(DBG, 86, 53);
            	        FOLLOWPUSH(FOLLOW_else_block_in_if_block402);
            	        else_block(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleif_blockEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"if_block");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */
            DBG->exitSubRule(DBG, 10);

            DBG->location(DBG, 86, 65);
             MATCHT(46, &FOLLOW_46_in_if_block405);
            if  (HASEXCEPTION())
            {
                goto ruleif_blockEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"if_block");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleif_blockEx; /* Prevent compiler warnings */
    ruleif_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 87, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"if_block");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end if_block */

/**
 * $ANTLR start else_block
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:89:1: else_block : 'or' ( 'maybe' boolean_expression 'so' )? statement_list ;
 */
static void
else_block(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"else_block");
    incRuleLevel();
    DBG->location(DBG, 89, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:90:2: ( 'or' ( 'maybe' boolean_expression 'so' )? statement_list )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:90:4: 'or' ( 'maybe' boolean_expression 'so' )? statement_list
        {
            DBG->location(DBG, 90, 4);
             MATCHT(55, &FOLLOW_55_in_else_block416);
            if  (HASEXCEPTION())
            {
                goto ruleelse_blockEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"else_block");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 90, 9);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:90:9: ( 'maybe' boolean_expression 'so' )?
            {
                int alt11=2;
                DBG->enterSubRule(DBG, 11);
                DBG->enterDecision(DBG, 11);

                switch ( LA(1) )
                {
                    case 52:
                    	{
                    		alt11=1;
                    	}
                        break;
                }

                DBG->exitDecision(DBG, 11);

                switch (alt11)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:90:10: 'maybe' boolean_expression 'so'
            	    {
            	        DBG->location(DBG, 90, 10);
            	         MATCHT(52, &FOLLOW_52_in_else_block419);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleelse_blockEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"else_block");
            	            decRuleLevel();
            	            return ;
            	        }

            	        DBG->location(DBG, 90, 18);
            	        FOLLOWPUSH(FOLLOW_boolean_expression_in_else_block421);
            	        boolean_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleelse_blockEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"else_block");
            	            decRuleLevel();
            	            return ;
            	        }

            	        DBG->location(DBG, 90, 37);
            	         MATCHT(59, &FOLLOW_59_in_else_block423);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleelse_blockEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"else_block");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

                }
                DBG->exitSubRule(DBG, 11);

            }
            DBG->location(DBG, 90, 44);
            FOLLOWPUSH(FOLLOW_statement_list_in_else_block427);
            statement_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleelse_blockEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"else_block");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleelse_blockEx; /* Prevent compiler warnings */
    ruleelse_blockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 91, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"else_block");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end else_block */

/**
 * $ANTLR start declaration_list
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:93:1: declaration_list options {k=2; } : ( ( identifier WASA )=> variable_declaration declaration_split ( declaration_list )? | ( procedure | function ) declaration_split ( declaration_list )? );
 */
static void
declaration_list(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
    incRuleLevel();
    DBG->location(DBG, 93, );

    {
        {
            //  /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:97:2: ( ( identifier WASA )=> variable_declaration declaration_split ( declaration_list )? | ( procedure | function ) declaration_split ( declaration_list )? )

            ANTLR3_UINT32 alt15;

            alt15=2;

            DBG->enterDecision(DBG, 15);

            {
                int LA15_0 = LA(1);
                if ( (synpred1_MAlice(ctx)) && (LA15_0 == LETTER))
                {
                    alt15=1;
                }
                else if ( (LA15_0 == THELOOKINGGLASS || LA15_0 == THEROOM))
                {
                    alt15=2;
                }
                else
                {
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }


                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 15;
                    EXCEPTION->state        = 0;
                    DBG->recognitionException(DBG, EXCEPTION);


                    goto ruledeclaration_listEx;

                }
            }
            DBG->exitDecision(DBG, 15);

            switch (alt15)
            {
        	case 1:
        	    DBG->enterAlt(DBG, 1);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:97:5: ( identifier WASA )=> variable_declaration declaration_split ( declaration_list )?
        	    {
        	        DBG->location(DBG, 97, 26);
        	        FOLLOWPUSH(FOLLOW_variable_declaration_in_declaration_list460);
        	        variable_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclaration_listEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
        	            decRuleLevel();
        	            return ;
        	        }

        	        DBG->location(DBG, 97, 47);
        	        FOLLOWPUSH(FOLLOW_declaration_split_in_declaration_list462);
        	        declaration_split(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclaration_listEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
        	            decRuleLevel();
        	            return ;
        	        }

        	        DBG->location(DBG, 97, 65);
        	        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:97:65: ( declaration_list )?
        	        {
        	            int alt12=2;
        	            DBG->enterSubRule(DBG, 12);
        	            DBG->enterDecision(DBG, 12);

        	            alt12 = cdfa12.predict(ctx, RECOGNIZER, ISTREAM, &cdfa12);
        	            if  (HASEXCEPTION())
        	            {
        	            	DBG->recognitionException(DBG, EXCEPTION);
        	                goto ruledeclaration_listEx;
        	            }
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruledeclaration_listEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
        	                decRuleLevel();
        	                return ;
        	            }

        	            DBG->exitDecision(DBG, 12);

        	            switch (alt12)
        	            {
        	        	case 1:
        	        	    DBG->enterAlt(DBG, 1);

        	        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:97:65: declaration_list
        	        	    {
        	        	        DBG->location(DBG, 97, 65);
        	        	        FOLLOWPUSH(FOLLOW_declaration_list_in_declaration_list464);
        	        	        declaration_list(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclaration_listEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
        	        	            decRuleLevel();
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	            DBG->exitSubRule(DBG, 12);

        	        }

        	    }
        	    break;
        	case 2:
        	    DBG->enterAlt(DBG, 2);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:98:4: ( procedure | function ) declaration_split ( declaration_list )?
        	    {
        	        DBG->location(DBG, 98, 4);
        	        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:98:4: ( procedure | function )
        	        {
        	            int alt13=2;
        	            DBG->enterSubRule(DBG, 13);
        	            DBG->enterDecision(DBG, 13);

        	            switch ( LA(1) )
        	            {
        	            case THELOOKINGGLASS:
        	            	{
        	            		alt13=1;
        	            	}
        	                break;
        	            case THEROOM:
        	            	{
        	            		alt13=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 13;
        	                EXCEPTION->state        = 0;
        	                DBG->recognitionException(DBG, EXCEPTION);


        	                goto ruledeclaration_listEx;

        	            }

        	            DBG->exitDecision(DBG, 13);

        	            switch (alt13)
        	            {
        	        	case 1:
        	        	    DBG->enterAlt(DBG, 1);

        	        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:98:5: procedure
        	        	    {
        	        	        DBG->location(DBG, 98, 5);
        	        	        FOLLOWPUSH(FOLLOW_procedure_in_declaration_list471);
        	        	        procedure(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclaration_listEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
        	        	            decRuleLevel();
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    DBG->enterAlt(DBG, 2);

        	        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:98:17: function
        	        	    {
        	        	        DBG->location(DBG, 98, 17);
        	        	        FOLLOWPUSH(FOLLOW_function_in_declaration_list475);
        	        	        function(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclaration_listEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
        	        	            decRuleLevel();
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	            DBG->exitSubRule(DBG, 13);

        	        }
        	        DBG->location(DBG, 98, 27);
        	        FOLLOWPUSH(FOLLOW_declaration_split_in_declaration_list478);
        	        declaration_split(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclaration_listEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
        	            decRuleLevel();
        	            return ;
        	        }

        	        DBG->location(DBG, 98, 45);
        	        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:98:45: ( declaration_list )?
        	        {
        	            int alt14=2;
        	            DBG->enterSubRule(DBG, 14);
        	            DBG->enterDecision(DBG, 14);

        	            alt14 = cdfa14.predict(ctx, RECOGNIZER, ISTREAM, &cdfa14);
        	            if  (HASEXCEPTION())
        	            {
        	            	DBG->recognitionException(DBG, EXCEPTION);
        	                goto ruledeclaration_listEx;
        	            }
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruledeclaration_listEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
        	                decRuleLevel();
        	                return ;
        	            }

        	            DBG->exitDecision(DBG, 14);

        	            switch (alt14)
        	            {
        	        	case 1:
        	        	    DBG->enterAlt(DBG, 1);

        	        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:98:45: declaration_list
        	        	    {
        	        	        DBG->location(DBG, 98, 45);
        	        	        FOLLOWPUSH(FOLLOW_declaration_list_in_declaration_list480);
        	        	        declaration_list(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclaration_listEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
        	        	            decRuleLevel();
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	            DBG->exitSubRule(DBG, 14);

        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclaration_listEx; /* Prevent compiler warnings */
    ruledeclaration_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 99, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"declaration_list");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end declaration_list */

/**
 * $ANTLR start variable_declaration
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:101:1: variable_declaration : identifier WASA type ( 'of' expression )? ( 'too' )? ;
 */
static void
variable_declaration(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"variable_declaration");
    incRuleLevel();
    DBG->location(DBG, 101, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:102:2: ( identifier WASA type ( 'of' expression )? ( 'too' )? )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:102:4: identifier WASA type ( 'of' expression )? ( 'too' )?
        {
            DBG->location(DBG, 102, 4);
            FOLLOWPUSH(FOLLOW_identifier_in_variable_declaration494);
            identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevariable_declarationEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"variable_declaration");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 102, 15);
             MATCHT(WASA, &FOLLOW_WASA_in_variable_declaration496);
            if  (HASEXCEPTION())
            {
                goto rulevariable_declarationEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"variable_declaration");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 102, 20);
            FOLLOWPUSH(FOLLOW_type_in_variable_declaration498);
            type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevariable_declarationEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"variable_declaration");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 102, 25);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:102:25: ( 'of' expression )?
            {
                int alt16=2;
                DBG->enterSubRule(DBG, 16);
                DBG->enterDecision(DBG, 16);

                switch ( LA(1) )
                {
                    case 54:
                    	{
                    		alt16=1;
                    	}
                        break;
                }

                DBG->exitDecision(DBG, 16);

                switch (alt16)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:102:26: 'of' expression
            	    {
            	        DBG->location(DBG, 102, 26);
            	         MATCHT(54, &FOLLOW_54_in_variable_declaration501);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariable_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"variable_declaration");
            	            decRuleLevel();
            	            return ;
            	        }

            	        DBG->location(DBG, 102, 31);
            	        FOLLOWPUSH(FOLLOW_expression_in_variable_declaration503);
            	        expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariable_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"variable_declaration");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

                }
                DBG->exitSubRule(DBG, 16);

            }
            DBG->location(DBG, 102, 44);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:102:44: ( 'too' )?
            {
                int alt17=2;
                DBG->enterSubRule(DBG, 17);
                DBG->enterDecision(DBG, 17);

                switch ( LA(1) )
                {
                    case 60:
                    	{
                    		alt17=1;
                    	}
                        break;
                }

                DBG->exitDecision(DBG, 17);

                switch (alt17)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:102:44: 'too'
            	    {
            	        DBG->location(DBG, 102, 44);
            	         MATCHT(60, &FOLLOW_60_in_variable_declaration507);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariable_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"variable_declaration");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

                }
                DBG->exitSubRule(DBG, 17);

            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulevariable_declarationEx; /* Prevent compiler warnings */
    rulevariable_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 102, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"variable_declaration");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end variable_declaration */

/**
 * $ANTLR start input_statement
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:104:1: input_statement : 'what was' lvalue '?' ;
 */
static void
input_statement(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"input_statement");
    incRuleLevel();
    DBG->location(DBG, 104, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:105:2: ( 'what was' lvalue '?' )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:105:4: 'what was' lvalue '?'
        {
            DBG->location(DBG, 105, 4);
             MATCHT(61, &FOLLOW_61_in_input_statement518);
            if  (HASEXCEPTION())
            {
                goto ruleinput_statementEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"input_statement");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 105, 15);
            FOLLOWPUSH(FOLLOW_lvalue_in_input_statement520);
            lvalue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinput_statementEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"input_statement");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 105, 22);
             MATCHT(42, &FOLLOW_42_in_input_statement522);
            if  (HASEXCEPTION())
            {
                goto ruleinput_statementEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"input_statement");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinput_statementEx; /* Prevent compiler warnings */
    ruleinput_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 105, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"input_statement");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end input_statement */

/**
 * $ANTLR start spoke_statement
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:107:1: spoke_statement : expression SPOKE ;
 */
static void
spoke_statement(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"spoke_statement");
    incRuleLevel();
    DBG->location(DBG, 107, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:108:2: ( expression SPOKE )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:108:4: expression SPOKE
        {
            DBG->location(DBG, 108, 4);
            FOLLOWPUSH(FOLLOW_expression_in_spoke_statement532);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulespoke_statementEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"spoke_statement");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 108, 15);
             MATCHT(SPOKE, &FOLLOW_SPOKE_in_spoke_statement534);
            if  (HASEXCEPTION())
            {
                goto rulespoke_statementEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"spoke_statement");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulespoke_statementEx; /* Prevent compiler warnings */
    rulespoke_statementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 108, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"spoke_statement");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end spoke_statement */

/**
 * $ANTLR start expression
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:111:1: expression : additive_expr ;
 */
static void
expression(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"expression");
    incRuleLevel();
    DBG->location(DBG, 111, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:112:2: ( additive_expr )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:112:4: additive_expr
        {
            DBG->location(DBG, 112, 4);
            FOLLOWPUSH(FOLLOW_additive_expr_in_expression544);
            additive_expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"expression");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 113, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"expression");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end expression */

/**
 * $ANTLR start assignment_expr
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:115:1: assignment_expr : lvalue 'became' expression ;
 */
static void
assignment_expr(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"assignment_expr");
    incRuleLevel();
    DBG->location(DBG, 115, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:116:2: ( lvalue 'became' expression )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:116:4: lvalue 'became' expression
        {
            DBG->location(DBG, 116, 4);
            FOLLOWPUSH(FOLLOW_lvalue_in_assignment_expr555);
            lvalue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignment_exprEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"assignment_expr");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 116, 11);
             MATCHT(BECAME, &FOLLOW_BECAME_in_assignment_expr557);
            if  (HASEXCEPTION())
            {
                goto ruleassignment_exprEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"assignment_expr");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 116, 20);
            FOLLOWPUSH(FOLLOW_expression_in_assignment_expr559);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignment_exprEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"assignment_expr");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignment_exprEx; /* Prevent compiler warnings */
    ruleassignment_exprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 117, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"assignment_expr");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end assignment_expr */

/**
 * $ANTLR start lvalue
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:119:1: lvalue : identifier ( '\\'s' expression 'piece' )? ;
 */
static void
lvalue(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"lvalue");
    incRuleLevel();
    DBG->location(DBG, 119, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:119:8: ( identifier ( '\\'s' expression 'piece' )? )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:119:10: identifier ( '\\'s' expression 'piece' )?
        {
            DBG->location(DBG, 119, 10);
            FOLLOWPUSH(FOLLOW_identifier_in_lvalue570);
            identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelvalueEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"lvalue");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 119, 21);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:119:21: ( '\\'s' expression 'piece' )?
            {
                int alt18=2;
                DBG->enterSubRule(DBG, 18);
                DBG->enterDecision(DBG, 18);

                switch ( LA(1) )
                {
                    case 43:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                DBG->exitDecision(DBG, 18);

                switch (alt18)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:119:22: '\\'s' expression 'piece'
            	    {
            	        DBG->location(DBG, 119, 22);
            	         MATCHT(43, &FOLLOW_43_in_lvalue573);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelvalueEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"lvalue");
            	            decRuleLevel();
            	            return ;
            	        }

            	        DBG->location(DBG, 119, 28);
            	        FOLLOWPUSH(FOLLOW_expression_in_lvalue575);
            	        expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelvalueEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"lvalue");
            	            decRuleLevel();
            	            return ;
            	        }

            	        DBG->location(DBG, 119, 39);
            	         MATCHT(57, &FOLLOW_57_in_lvalue577);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelvalueEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"lvalue");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

                }
                DBG->exitSubRule(DBG, 18);

            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulelvalueEx; /* Prevent compiler warnings */
    rulelvalueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 120, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"lvalue");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end lvalue */

/**
 * $ANTLR start additive_expr
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:122:1: additive_expr : multiplicactive_expr ( ( '+' | '-' ) multiplicactive_expr )* ;
 */
static void
additive_expr(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"additive_expr");
    incRuleLevel();
    DBG->location(DBG, 122, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:123:2: ( multiplicactive_expr ( ( '+' | '-' ) multiplicactive_expr )* )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:123:4: multiplicactive_expr ( ( '+' | '-' ) multiplicactive_expr )*
        {
            DBG->location(DBG, 123, 4);
            FOLLOWPUSH(FOLLOW_multiplicactive_expr_in_additive_expr590);
            multiplicactive_expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleadditive_exprEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"additive_expr");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 123, 25);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:123:25: ( ( '+' | '-' ) multiplicactive_expr )*

            DBG->enterSubRule(DBG, 19);

            for (;;)
            {
                int alt19=2;
                DBG->enterDecision(DBG, 19);

                switch ( LA(1) )
                {
                case 31:
                case 32:
                	{
                		alt19=1;
                	}
                    break;

                }

                DBG->exitDecision(DBG, 19);

                switch (alt19)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:123:26: ( '+' | '-' ) multiplicactive_expr
            	    {
            	        DBG->location(DBG, 123, 26);
            	        if ( ((LA(1) >= 31) && (LA(1) <= 32)) )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return ;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            DBG->recognitionException(DBG, EXCEPTION);
            	            goto ruleadditive_exprEx;
            	        }

            	        DBG->location(DBG, 123, 36);
            	        FOLLOWPUSH(FOLLOW_multiplicactive_expr_in_additive_expr599);
            	        multiplicactive_expr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadditive_exprEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"additive_expr");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop19;	/* break out of the loop */
            	    break;
                }
            }
            loop19: ; /* Jump out to here if this rule does not match */
            DBG->exitSubRule(DBG, 19);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleadditive_exprEx; /* Prevent compiler warnings */
    ruleadditive_exprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 124, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"additive_expr");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end additive_expr */

/**
 * $ANTLR start multiplicactive_expr
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:126:1: multiplicactive_expr : bitwise_expr ( ( '*' | '/' | '%' ) bitwise_expr )* ;
 */
static void
multiplicactive_expr(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"multiplicactive_expr");
    incRuleLevel();
    DBG->location(DBG, 126, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:127:2: ( bitwise_expr ( ( '*' | '/' | '%' ) bitwise_expr )* )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:127:4: bitwise_expr ( ( '*' | '/' | '%' ) bitwise_expr )*
        {
            DBG->location(DBG, 127, 4);
            FOLLOWPUSH(FOLLOW_bitwise_expr_in_multiplicactive_expr612);
            bitwise_expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemultiplicactive_exprEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"multiplicactive_expr");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 127, 17);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:127:17: ( ( '*' | '/' | '%' ) bitwise_expr )*

            DBG->enterSubRule(DBG, 20);

            for (;;)
            {
                int alt20=2;
                DBG->enterDecision(DBG, 20);

                switch ( LA(1) )
                {
                case 27:
                case 30:
                case 34:
                	{
                		alt20=1;
                	}
                    break;

                }

                DBG->exitDecision(DBG, 20);

                switch (alt20)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:127:18: ( '*' | '/' | '%' ) bitwise_expr
            	    {
            	        DBG->location(DBG, 127, 18);
            	        if ( LA(1) == 27 || LA(1) == 30 || LA(1) == 34 )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return ;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            DBG->recognitionException(DBG, EXCEPTION);
            	            goto rulemultiplicactive_exprEx;
            	        }

            	        DBG->location(DBG, 127, 32);
            	        FOLLOWPUSH(FOLLOW_bitwise_expr_in_multiplicactive_expr623);
            	        bitwise_expr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultiplicactive_exprEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"multiplicactive_expr");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */
            DBG->exitSubRule(DBG, 20);


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultiplicactive_exprEx; /* Prevent compiler warnings */
    rulemultiplicactive_exprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 128, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"multiplicactive_expr");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end multiplicactive_expr */

/**
 * $ANTLR start bitwise_expr
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:130:1: bitwise_expr : unary_expr ( ( '^' | '|' | '&' ) unary_expr )* ;
 */
static void
bitwise_expr(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"bitwise_expr");
    incRuleLevel();
    DBG->location(DBG, 130, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:131:2: ( unary_expr ( ( '^' | '|' | '&' ) unary_expr )* )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:131:4: unary_expr ( ( '^' | '|' | '&' ) unary_expr )*
        {
            DBG->location(DBG, 131, 4);
            FOLLOWPUSH(FOLLOW_unary_expr_in_bitwise_expr636);
            unary_expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebitwise_exprEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"bitwise_expr");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 131, 15);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:131:15: ( ( '^' | '|' | '&' ) unary_expr )*

            DBG->enterSubRule(DBG, 21);

            for (;;)
            {
                int alt21=2;
                DBG->enterDecision(DBG, 21);

                switch ( LA(1) )
                {
                case 29:
                case 44:
                case 62:
                	{
                		alt21=1;
                	}
                    break;

                }

                DBG->exitDecision(DBG, 21);

                switch (alt21)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:131:16: ( '^' | '|' | '&' ) unary_expr
            	    {
            	        DBG->location(DBG, 131, 16);
            	        if ( LA(1) == 29 || LA(1) == 44 || LA(1) == 62 )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return ;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            DBG->recognitionException(DBG, EXCEPTION);
            	            goto rulebitwise_exprEx;
            	        }

            	        DBG->location(DBG, 131, 30);
            	        FOLLOWPUSH(FOLLOW_unary_expr_in_bitwise_expr647);
            	        unary_expr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitwise_exprEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"bitwise_expr");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop21;	/* break out of the loop */
            	    break;
                }
            }
            loop21: ; /* Jump out to here if this rule does not match */
            DBG->exitSubRule(DBG, 21);


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebitwise_exprEx; /* Prevent compiler warnings */
    rulebitwise_exprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 132, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"bitwise_expr");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end bitwise_expr */

/**
 * $ANTLR start unary_expr
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:134:1: unary_expr : ( ( '+' | '-' | '~' | '!' ) unary_expr | constant | lvalue | LPAREN additive_expr RPAREN );
 */
static void
unary_expr(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"unary_expr");
    incRuleLevel();
    DBG->location(DBG, 134, );

    {
        {
            //  /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:135:2: ( ( '+' | '-' | '~' | '!' ) unary_expr | constant | lvalue | LPAREN additive_expr RPAREN )

            ANTLR3_UINT32 alt22;

            alt22=4;

            DBG->enterDecision(DBG, 22);

            switch ( LA(1) )
            {
            case 25:
            case 31:
            case 32:
            case 64:
            	{
            		alt22=1;
            	}
                break;
            case CHARACTER_LITERAL:
            case NUMBER_LITERAL:
            	{
            		alt22=2;
            	}
                break;
            case LETTER:
            	{
            		alt22=3;
            	}
                break;
            case LPAREN:
            	{
            		alt22=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;
                DBG->recognitionException(DBG, EXCEPTION);


                goto ruleunary_exprEx;

            }

            DBG->exitDecision(DBG, 22);

            switch (alt22)
            {
        	case 1:
        	    DBG->enterAlt(DBG, 1);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:135:4: ( '+' | '-' | '~' | '!' ) unary_expr
        	    {
        	        DBG->location(DBG, 135, 4);
        	        if ( LA(1) == 25 || ((LA(1) >= 31) && (LA(1) <= 32)) || LA(1) == 64 )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = NULL;

        	            DBG->recognitionException(DBG, EXCEPTION);
        	            goto ruleunary_exprEx;
        	        }

        	        DBG->location(DBG, 135, 28);
        	        FOLLOWPUSH(FOLLOW_unary_expr_in_unary_expr676);
        	        unary_expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunary_exprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"unary_expr");
        	            decRuleLevel();
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    DBG->enterAlt(DBG, 2);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:136:4: constant
        	    {
        	        DBG->location(DBG, 136, 4);
        	        FOLLOWPUSH(FOLLOW_constant_in_unary_expr681);
        	        constant(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunary_exprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"unary_expr");
        	            decRuleLevel();
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    DBG->enterAlt(DBG, 3);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:137:4: lvalue
        	    {
        	        DBG->location(DBG, 137, 4);
        	        FOLLOWPUSH(FOLLOW_lvalue_in_unary_expr686);
        	        lvalue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunary_exprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"unary_expr");
        	            decRuleLevel();
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    DBG->enterAlt(DBG, 4);

        	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:138:4: LPAREN additive_expr RPAREN
        	    {
        	        DBG->location(DBG, 138, 4);
        	         MATCHT(LPAREN, &FOLLOW_LPAREN_in_unary_expr691);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunary_exprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"unary_expr");
        	            decRuleLevel();
        	            return ;
        	        }

        	        DBG->location(DBG, 138, 11);
        	        FOLLOWPUSH(FOLLOW_additive_expr_in_unary_expr693);
        	        additive_expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunary_exprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"unary_expr");
        	            decRuleLevel();
        	            return ;
        	        }

        	        DBG->location(DBG, 138, 25);
        	         MATCHT(RPAREN, &FOLLOW_RPAREN_in_unary_expr695);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunary_exprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"unary_expr");
        	            decRuleLevel();
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleunary_exprEx; /* Prevent compiler warnings */
    ruleunary_exprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 139, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"unary_expr");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end unary_expr */

/**
 * $ANTLR start boolean_expression
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:141:1: boolean_expression : single_boolean_expression ( ( '&&' | '||' ) single_boolean_expression )* ;
 */
static void
boolean_expression(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"boolean_expression");
    incRuleLevel();
    DBG->location(DBG, 141, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:142:2: ( single_boolean_expression ( ( '&&' | '||' ) single_boolean_expression )* )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:142:4: single_boolean_expression ( ( '&&' | '||' ) single_boolean_expression )*
        {
            DBG->location(DBG, 142, 4);
            FOLLOWPUSH(FOLLOW_single_boolean_expression_in_boolean_expression706);
            single_boolean_expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleboolean_expressionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"boolean_expression");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 142, 30);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:142:30: ( ( '&&' | '||' ) single_boolean_expression )*

            DBG->enterSubRule(DBG, 23);

            for (;;)
            {
                int alt23=2;
                DBG->enterDecision(DBG, 23);

                switch ( LA(1) )
                {
                case 28:
                case 63:
                	{
                		alt23=1;
                	}
                    break;

                }

                DBG->exitDecision(DBG, 23);

                switch (alt23)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:142:31: ( '&&' | '||' ) single_boolean_expression
            	    {
            	        DBG->location(DBG, 142, 31);
            	        if ( LA(1) == 28 || LA(1) == 63 )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return ;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            DBG->recognitionException(DBG, EXCEPTION);
            	            goto ruleboolean_expressionEx;
            	        }

            	        DBG->location(DBG, 142, 45);
            	        FOLLOWPUSH(FOLLOW_single_boolean_expression_in_boolean_expression717);
            	        single_boolean_expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleboolean_expressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"boolean_expression");
            	            decRuleLevel();
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop23;	/* break out of the loop */
            	    break;
                }
            }
            loop23: ; /* Jump out to here if this rule does not match */
            DBG->exitSubRule(DBG, 23);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleboolean_expressionEx; /* Prevent compiler warnings */
    ruleboolean_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 143, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"boolean_expression");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end boolean_expression */

/**
 * $ANTLR start single_boolean_expression
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:145:1: single_boolean_expression : expression ( '==' | '!=' | '<' | '<=' | '>' | '>=' ) expression ;
 */
static void
single_boolean_expression(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"single_boolean_expression");
    incRuleLevel();
    DBG->location(DBG, 145, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:146:2: ( expression ( '==' | '!=' | '<' | '<=' | '>' | '>=' ) expression )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:146:5: expression ( '==' | '!=' | '<' | '<=' | '>' | '>=' ) expression
        {
            DBG->location(DBG, 146, 5);
            FOLLOWPUSH(FOLLOW_expression_in_single_boolean_expression732);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesingle_boolean_expressionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"single_boolean_expression");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 146, 16);
            if ( LA(1) == 26 || ((LA(1) >= 37) && (LA(1) <= 41)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                DBG->recognitionException(DBG, EXCEPTION);
                goto rulesingle_boolean_expressionEx;
            }

            DBG->location(DBG, 146, 57);
            FOLLOWPUSH(FOLLOW_expression_in_single_boolean_expression759);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesingle_boolean_expressionEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"single_boolean_expression");
                decRuleLevel();
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesingle_boolean_expressionEx; /* Prevent compiler warnings */
    rulesingle_boolean_expressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 147, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"single_boolean_expression");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end single_boolean_expression */

/**
 * $ANTLR start identifier
 * /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:149:1: identifier : LETTER ( LETTER | '0' .. '9' | '_' )* ;
 */
static void
identifier(pMAliceParser ctx)
{
    /* Initialize rule variables
     */

    if ( getRuleLevel()==0 )
    {
    	DBG->commence(DBG);
    }
    DBG->enterRule(DBG, getGrammarFileName(), (const char *)"identifier");
    incRuleLevel();
    DBG->location(DBG, 149, );

    {
        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:150:2: ( LETTER ( LETTER | '0' .. '9' | '_' )* )
        DBG->enterAlt(DBG, 1);

        // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:150:4: LETTER ( LETTER | '0' .. '9' | '_' )*
        {
            DBG->location(DBG, 150, 4);
             MATCHT(LETTER, &FOLLOW_LETTER_in_identifier770);
            if  (HASEXCEPTION())
            {
                goto ruleidentifierEx;
            }
            if (HASFAILED())
            {
                DBG->exitRule(DBG, getGrammarFileName(), (const char *)"identifier");
                decRuleLevel();
                return ;
            }

            DBG->location(DBG, 150, 11);
            // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:150:11: ( LETTER | '0' .. '9' | '_' )*

            DBG->enterSubRule(DBG, 24);

            for (;;)
            {
                int alt24=2;
                DBG->enterDecision(DBG, 24);

                switch ( LA(1) )
                {
                case LETTER:
                case 45:
                	{
                		alt24=1;
                	}
                    break;

                }

                DBG->exitDecision(DBG, 24);

                switch (alt24)
                {
            	case 1:
            	    DBG->enterAlt(DBG, 1);

            	    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:
            	    {
            	        DBG->location(DBG, 150, 11);
            	        if ( LA(1) == LETTER || LA(1) == 45 )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return ;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            DBG->recognitionException(DBG, EXCEPTION);
            	            goto ruleidentifierEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop24;	/* break out of the loop */
            	    break;
                }
            }
            loop24: ; /* Jump out to here if this rule does not match */
            DBG->exitSubRule(DBG, 24);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    DBG->location(DBG, 150, );

    DBG->exitRule(DBG, getGrammarFileName(), (const char *)"identifier");
    decRuleLevel();
    if ( getRuleLevel()==0 )
    {
    	DBG->terminate(DBG);
    }


    return ;
}
/* $ANTLR end identifier */

// $ANTLR start synpred1_MAlice
static void synpred1_MAlice_fragment(pMAliceParser ctx )
{
    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:97:5: ( identifier WASA )
    DBG->enterAlt(DBG, 1);

    // /homes/tr111/Desktop/MaliceFinal/malice/grammar/MAlice.g:97:6: identifier WASA
    {
        DBG->location(DBG, 97, 6);
        FOLLOWPUSH(FOLLOW_identifier_in_synpred1_MAlice453);
        identifier(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_MAliceEx;
        }
        if (HASFAILED())
        {
            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"synpred1_MAlice");
            decRuleLevel();
            return ;
        }

        DBG->location(DBG, 97, 17);
         MATCHT(WASA, &FOLLOW_WASA_in_synpred1_MAlice455);
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_MAliceEx;
        }
        if (HASFAILED())
        {
            DBG->exitRule(DBG, getGrammarFileName(), (const char *)"synpred1_MAlice");
            decRuleLevel();
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_MAliceEx; /* Prevent compiler warnings */
rulesynpred1_MAliceEx: ;

}
// $ANTLR end synpred1_MAlice
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_MAlice(pMAliceParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    DBG->beginBacktrack(DBG, BACKTRACKING);
    start	= MARK();
    synpred1_MAlice_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    DBG->endBacktrack(DBG, BACKTRACKING, success);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
